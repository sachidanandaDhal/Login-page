import { css } from "lit";
const DraggableMixin = (superClass) => {
  class DraggableMixinEl extends superClass {
    static get styles() {
      return [
        // @ts-ignore
        super.styles,
        css`
          /* NOTE this requires explicit properties to work as expected
					 * possibly a combination of left-min/max width/height, -top/-left initial values
					 * also note z variables below
					 */
          :host,
          [drag-able] {
            margin: 0;
            --drag-left-min: 0vw;
            --drag-left: auto;
            --drag-left-max: calc(100vw - 4rem);
            --drag-top-min: 0vh;
            --drag-top: auto;
            --drag-top-max: calc(100vh - 4rem);
            /* NOTE can adjust per content */
            --drag-top-max: calc(100vh - var(--drag-height));
            --drag-left-max: calc(100vw - var(--drag-width));
          }
          :host([drag-able]),
          ::slotted([drag-able]),
          :is([drag-able]) {
            position: fixed;
            cursor: move;
            top: clamp(
              var(--drag-top-min, 0vh),
              var(--drag-top, 0),
              var(--drag-top-max, calc(100vh - var(--drag-height, 50px)))
            );
            left: clamp(
              var(--drag-left-min, 0vw),
              var(--drag-left, 0),
              var(--drag-left-max, calc(100vw - var(--drag-width, 20px)))
            );
            z-index: var(--drag-able-z, auto);
          }
          :host(:is([drag-able][active])),
          ::slotted(:is([drag-able][active])),
          :is([drag-able][active]) {
            /* below Bulma modal (40) above omni-tooltip (38) */
            z-index: var(--drag-z, 39);
          }
        `
      ];
    }
    static get properties() {
      return { dragable: { type: Boolean, attribute: "drag-able" } };
    }
    constructor() {
      super();
      this.addEventListener("pointerdown", this._dragstart);
      this._dragend = this._dragend.bind(this);
      this._dragmove = this._dragmove.bind(this);
      console.warn("The DraggableMixin is deprecated and will be removed in the upcoming Omni-UI 8.0 release. Please use the DraggableController instead. https://omni-ui.annalect.com/draggable-controller");
    }
    /* Supports host or element in shadowRoot */
    _draggable(el = this) {
      if (!el.dragable) {
        el.dragable = true;
        if (el === this) {
          return;
        }
        el.setAttribute("drag-able", "");
      }
      el._dragposition = this._dragposition;
      el._dragend = this.constructor.prototype._dragend.bind(el);
      el._dragmove = this.constructor.prototype._dragmove.bind(el);
      el.addEventListener("pointerdown", this._dragstart);
    }
    _undraggable(el = this) {
      el.dragable = false;
      el._dragend();
    }
    disconnectedCallback() {
      super.disconnectedCallback();
      this._dragend();
    }
    _dragend() {
      this.removeAttribute("active");
      this.removeEventListener("drag", this._dragposition);
      const { ownerDocument } = this;
      ownerDocument.removeEventListener("pointermove", this._dragmove);
      ownerDocument.removeEventListener("pointerup", this._dragend);
      ownerDocument.removeEventListener("pointerout", this._dragend);
      ownerDocument.removeEventListener("mouseleave", this._dragend);
      ownerDocument.removeEventListener("mouseout", this._dragend);
      this.dispatchEvent(new CustomEvent("dragend", { bubbles: true, composed: true, detail: this._position }));
    }
    _dragstart(event) {
      const { pageX, pageY, ctrlKey, button } = event;
      if (!this.dragable || ctrlKey || button)
        return;
      this.setAttribute("active", "");
      this.addEventListener("drag", this._dragposition);
      const { left, top, width, height } = this.getBoundingClientRect();
      const { innerWidth, innerHeight } = self;
      const offsetX = pageX - left;
      const offsetY = pageY - top;
      this._position = {
        left,
        top,
        offsetX,
        offsetY,
        width,
        height,
        availableWidth: innerWidth,
        availableHeight: innerHeight
      };
      this.dispatchEvent(new CustomEvent("dragstart", { bubbles: true, composed: true, detail: this._position }));
      const { ownerDocument } = this;
      ownerDocument.addEventListener("mouseleave", this._dragend);
      ownerDocument.addEventListener("mouseout", this._dragend);
      ownerDocument.addEventListener("pointerout", this._dragend);
      ownerDocument.addEventListener("pointerup", this._dragend);
      ownerDocument.addEventListener("pointermove", this._dragmove);
      this._dragmove(event);
    }
    _dragposition() {
      cancelAnimationFrame(this._dragrender);
      this._dragrender = requestAnimationFrame(() => {
        const { style, _position } = this;
        const { left, top, width, height } = _position;
        style.setProperty("--drag-left", `${Math.round(left)}px`);
        style.setProperty("--drag-top", `${Math.round(top)}px`);
        style.setProperty("--drag-width", `${Math.round(width)}px`);
        style.setProperty("--drag-height", `${Math.round(height)}px`);
      });
    }
    _dragrender(_dragrender) {
      throw new Error("Method not implemented.");
    }
    _dragmove(event) {
      event.preventDefault();
      const { pageX, pageY } = event;
      const { _position } = this;
      const { offsetX, offsetY } = _position;
      const left = pageX - offsetX;
      const top = pageY - offsetY;
      _position.left = left;
      _position.top = top;
      this.dispatchEvent(new CustomEvent("drag", { bubbles: true, composed: true, detail: _position }));
    }
  }
  return DraggableMixinEl;
};
export {
  DraggableMixin
};
//# sourceMappingURL=draggable-mixin.js.map
