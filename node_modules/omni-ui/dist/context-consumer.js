const providerSymbol = Symbol("provider");
const contextSymbol = Symbol("context");
const EVENT_TYPE = "context-provider";
const getProvider = async (identifier, context) => {
  const eventInit = { bubbles: true, composed: true, detail: { identifier } };
  const event = new CustomEvent(EVENT_TYPE, eventInit);
  context.dispatchEvent(event);
  if (!event.detail.provider) {
    await new Promise((res) => setTimeout(res, 0));
    context.dispatchEvent(event);
  }
  return event.detail.provider;
};
const contextConsumerMixin = (SuperClass) => class Consumer extends SuperClass {
  constructor() {
    super();
    this.onContextChanged = this.onContextChanged.bind(this);
  }
  get context() {
    if (this[providerSymbol]) {
      return this[providerSymbol].value;
    }
    return void 0;
  }
  async _discoverContextProvider() {
    this._forgetContextProvider();
    this[providerSymbol] = await getProvider(contextSymbol, this);
    if (this[providerSymbol]) {
      this[providerSymbol].addEventListener("context-changed", this.onContextChanged);
    }
    if (this.context !== void 0) {
      this.onContextChanged(new Event("context-changed"));
    }
  }
  _forgetContextProvider() {
    if (this[providerSymbol]) {
      this[providerSymbol].removeEventListener("context-changed", this.onContextChanged);
    }
    this[providerSymbol] = null;
  }
  connectedCallback() {
    if (super.connectedCallback) {
      super.connectedCallback();
    }
    this._discoverContextProvider();
  }
  disconnectedCallback() {
    this._forgetContextProvider();
    if (super.disconnectedCallback) {
      super.disconnectedCallback();
    }
  }
  /**
   * Callback executed when the nearest Provider changes its `value` property.
   */
  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-empty-function
  onContextChanged() {
  }
};
export {
  EVENT_TYPE,
  contextConsumerMixin,
  contextSymbol,
  providerSymbol
};
//# sourceMappingURL=context-consumer.js.map
