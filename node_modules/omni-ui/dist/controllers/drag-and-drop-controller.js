class DragAndDropController {
  /**
   * @param {OmniElement} host - your component host element that extends OmniElement. pass as: `this`
   * @param {DragAndDropOptions=} options -
   * @param {DropCb=} dropCb - add a callback function to handle moves within your list of items
   * @example
   * ```js
   * constructor(){
   *   super();
   *   this.myList = ['item 1', 'item 2', 'item 3'];
   *   this.dragController = new DragAndDropController(this);
   * }
   * render(){
   *  return html`
   *  <div drag-container drag-list="myList">
   *   ${this.list.map((item, idx) => html`
   *       <div drag-idx=${idx}>
   *          <omni-icon drag-handle></omni-icon>
   *          ${item}
   *       </div>
   *    `)}
   *   </div>
   * `
   * }
   * ```
   */
  constructor(host, options = {
    dragContainerQueries: ["[drag-container]"],
    shadowClass: "drag-shadow",
    ghostClass: "drag-ghost",
    noDropIdxs: [],
    animationDuration: 350
  }, dropCb = null) {
    this.#participatingElements = /* @__PURE__ */ new Map();
    this.#dropTargetLines = [];
    /** used to fix safari bug on first click pointerevent does not listen */
    this.#pointerEventHandled = false;
    this.#isDragging = false;
    this.#isAnimating = false;
    this.debug = false;
    this.#defaultDropCb = ({ container, moveToIdx, moveFromIdx }) => {
      const listName = container.getAttribute("drag-list");
      if (!listName) {
        this.#log("no list name found, no default move");
        return;
      }
      this.#log("default DropCb. moveFromIdx, moveToIdx", moveFromIdx, moveToIdx);
      try {
        const array = this.#host[listName];
        this.#host[listName] = moveItemsInArray(array, moveFromIdx, moveToIdx);
        this.#host.requestUpdate();
      } catch (err) {
        console.warn("default drop cb error", err);
      }
    };
    this.#handlePointerDown = (e) => {
      this.#log("pointer down");
      if (this.#pointerEventHandled)
        return;
      this.#pointerEventHandled = true;
      const target = e.target;
      if (!target.closest("[drag-handle]")) {
        return;
      }
      this.#isDragging = true;
      this.#draggingHandle = target.closest("[drag-handle]");
      this.#draggingElement = target.closest("[drag-idx]");
      this.#draggingElement.setAttribute("draggable", "true");
      this.#draggingContainer = e.currentTarget;
      this.#log("set drag handle:", this.#draggingHandle);
      this.#log("set dragging element:", this.#draggingElement);
      this.#log("set dragging container:", this.#draggingContainer);
      this.#draggingContainer.addEventListener("dragstart", this.#handleDragStart);
      this.#draggingContainer.addEventListener("dragover", this.#handleDragOver);
      this.#draggingContainer.addEventListener("drop", this.#handleDrop);
      this.#draggingContainer.addEventListener("dragend", this.#handleDragCancel);
    };
    this.#handlePointerUp = (e) => {
      const dragContainer = e.currentTarget;
      dragContainer.removeEventListener("dragstart", this.#handleDragStart);
      dragContainer.removeEventListener("dragover", this.#handleDragOver);
      dragContainer.removeEventListener("drop", this.#handleDrop);
      dragContainer.removeEventListener("dragend", this.#handleDragCancel);
      this.#pointerEventHandled = false;
      this.#isDragging = false;
    };
    this.#makeGhostElement = (originalElement) => {
      const clone = originalElement.cloneNode(true);
      clone.setAttribute("drag-and-drop-clone", "");
      const { width, height } = originalElement.getBoundingClientRect();
      clone.classList.add(this.#ghostClass);
      clone.style.height = `${height}px`;
      clone.style.width = `${width}px`;
      clone.style.position = "absolute";
      clone.style.top = `${originalElement.offsetTop}px`;
      clone.style.left = `${originalElement.offsetLeft}px`;
      clone.style.zIndex = "-1";
      return clone;
    };
    this.#makeShadowElement = (originalElement) => {
      const clone = document.createElement(originalElement.tagName);
      clone.setAttribute("drag-and-drop-clone", "");
      clone.classList.add(this.#shadowClass);
      const { width, height } = originalElement.getBoundingClientRect();
      clone.style.height = `${height}px`;
      clone.style.width = `${width}px`;
      clone.style.zIndex = "1";
      return clone;
    };
    this.#handleDragStart = (e) => {
      this.#log("drag start");
      e.dataTransfer.effectAllowed = "move";
      this.#draggingElementGhost = this.#makeGhostElement(this.#draggingElement);
      this.#draggingElementShadow = this.#makeShadowElement(this.#draggingElement);
      this.#draggingContainer = e.currentTarget;
      this.#draggingContainer.appendChild(this.#draggingElementGhost);
      e.dataTransfer.setDragImage(this.#draggingElementGhost, e.offsetX, e.offsetY);
      setTimeout(() => {
        this.#draggingContainer.setAttribute("dragging", "");
        const nextSibling = this.#draggingElement.nextElementSibling;
        if (nextSibling) {
          this.#draggingContainer.insertBefore(this.#draggingElementShadow, nextSibling);
        } else {
          this.#draggingContainer.appendChild(this.#draggingElementShadow);
        }
        this.#draggingElement.style.display = "none";
      });
    };
    this.#handleDragEnter = (e) => {
      e.preventDefault();
      this.#dropContainerCandidate = e.currentTarget;
      this.#log("drag enter");
    };
    /** drag over fires continuously, when over */
    this.#handleDragOver = (e) => {
      e.preventDefault();
      this.#log("drag over");
      if (this.#isAnimating)
        return;
      const target = e.target;
      const dragLine = target.closest("omni-drop-line");
      this.#dropTarget = dragLine;
      if (dragLine && this.#isValidMove) {
        dragLine.setAttribute("drag-over", "");
      }
    };
    this.#handleDragLeave = (e) => {
      e.preventDefault();
      this.#log("drag leave", e.target);
      if (this.#isAnimating)
        return;
      const target = e.target;
      if (!target.closest("omni-drop-line"))
        return;
      const dragLine = target.closest("omni-drop-line");
      dragLine.removeAttribute("drag-over");
      if (!this.#isValidMove)
        return;
    };
    this.#handleDragCancel = () => {
      this.#log("drag cancel");
      if (this.#draggingElementShadow) {
        this.#draggingElementShadow.remove();
      }
      this.#draggingContainer?.removeAttribute("dragging");
      if (this.#isAnimating)
        return;
      if (this.#draggingElement) {
        this.#draggingElement.removeAttribute("draggable");
        this.#draggingElement.style.display = "";
      }
      this.#isDragging = false;
      this.#host.requestUpdate();
    };
    this.#handleDrop = async (e) => {
      this.#log("handle drop");
      e.stopPropagation();
      e.preventDefault();
      this.#draggingElement.removeAttribute("draggable");
      this.#draggingElement.style.display = "";
      this.#draggingElementShadow.remove();
      this.#dropTarget = e.target.closest("omni-drop-line");
      this.#dropTarget?.removeAttribute("drag-over");
      this.#dropContainerCandidate = e.currentTarget;
      if (this.#dropTarget?.tagName !== "OMNI-DROP-LINE") {
        this.#handleDragCancel();
        return;
      }
      const isValidMove = this.#isValidMove;
      if (!isValidMove) {
        this.#handleDragCancel();
        return;
      }
      this.#draggingContainer?.removeAttribute("dragging");
      await this.#animateDropped(e, isValidMove);
      this.#dropCb(isValidMove);
      this.#host.dispatchNewEvent("omni-drop", {
        detail: isValidMove
      });
      this.#isDragging = false;
    };
    this.#animateDropped = async (e, move) => {
      this.#log("animate dropped element into place START", move);
      this.#isAnimating = true;
      this.#draggingElement.style.visibility = "hidden";
      const animateAxis = this.#draggingContainer.getAttribute("drag-orientation") === "horizontal" ? "x" : "y";
      await Promise.all([
        this.#createDroppedElementAnimation(e, move),
        ...this.#createMovedElementsAnimations(move, animateAxis)
      ]);
      this.#draggingElement.style.visibility = "visible";
      this.#isAnimating = false;
      this.#log("animate dropped element into place END");
    };
    /** the line is styled from appending styles onto the host in host connected */
    this.#makeDropTargetLine = (dragContainer, idx) => {
      const targetEl = document.createElement("omni-drop-line");
      targetEl.setAttribute("drag-idx", String(idx));
      targetEl.style.display = "flex";
      targetEl.style.flexDirection = "row";
      targetEl.style.justifyContent = "center";
      if (dragContainer.getAttribute("drag-orientation") === "horizontal") {
        targetEl.style.flexDirection = "column";
        targetEl.style.alignItems = "center";
      }
      const template = `
      <div drop-line-container>
        <span dot dot-one> </span>
        <div drop-line></div>
        <span dot dot-two></span>
      </div>
    `;
      targetEl.innerHTML = template;
      return targetEl;
    };
    /** occasionnaly safari loses pointerdown events but not mousedown events.
     * check if pointerdown is already handling to avoid double handling
     * */
    this.#handleMouseDown = (e) => {
      if (this.#pointerEventHandled)
        return;
      else {
        this.#log("mousedown is handling");
        this.#handlePointerDown(e);
      }
    };
    this.#host = host;
    this.#host.addController(this);
    this.#dragContainersQueries = options.dragContainerQueries ?? ["[drag-container]"];
    this.#ghostClass = options.ghostClass ?? "drag-ghost";
    this.#shadowClass = options.shadowClass ?? "drag-shadow";
    this.#noDropIdxs = options.noDropIdxs ?? [];
    this.#animationDuration = options.animationDuration ?? 350;
    this.#dropCb = dropCb ?? this.#defaultDropCb;
  }
  #host;
  #dragContainersQueries;
  #ghostClass;
  #shadowClass;
  #noDropIdxs;
  #dropCb;
  #participatingElements;
  #dropTargetLines;
  #dropTarget;
  #dropContainerCandidate;
  #draggingHandle;
  #draggingElement;
  #draggingElementGhost;
  #draggingElementShadow;
  #draggingContainer;
  #animationDuration;
  #pointerEventHandled;
  #isDragging;
  #isAnimating;
  hostConnected() {
    this.#addLineStyles();
  }
  /** unregister and reregister all drag elements */
  hostUpdated() {
    if (this.#isDragging) {
      console.warn(
        "drag-and-drop-controller: your component updated while dragging. This is not recommended and you may see unexpected behavior."
      );
      return;
    }
    this.#unregisterParticipatingElements();
    this.#queryDragContainersAndRegisterParticipating();
  }
  /** unregister all drag elements. cleans up and removes all event listeners */
  hostDisconnected() {
    this.#unregisterParticipatingElements();
    this.#log("host disconnected. participating elements cleared:", this.#participatingElements);
  }
  #log(...args) {
    if (this.debug) {
      console.log("[dnd] ", ...args);
    }
  }
  #defaultDropCb;
  #addLineStyles() {
    const styleForHost = document.createElement("style");
    styleForHost.textContent = LINE_STYLES;
    this.#host.shadowRoot.appendChild(styleForHost);
  }
  #queryDragContainersAndRegisterParticipating() {
    const dragContainers = this.#dragContainersQueries.map((query) => {
      return [...this.#host.shadowRoot.querySelectorAll(query)];
    }).reduce((acc, val) => acc.concat(val), []).flat().filter((one) => one);
    this.#registerParticipatingElements(dragContainers);
  }
  #handlePointerDown;
  #handlePointerUp;
  #makeGhostElement;
  #makeShadowElement;
  #handleDragStart;
  #handleDragEnter;
  #handleDragOver;
  #handleDragLeave;
  #handleDragCancel;
  #handleDrop;
  #getInitialAndFinalPositions(move, axis) {
    const draggingContainerRect = this.#draggingContainer.getBoundingClientRect();
    const dimension = axis === "x" ? "width" : "height";
    const lineDimension = this.#draggingContainer.querySelector("omni-drop-line").getBoundingClientRect()[dimension];
    const itemsAfterDrop = moveItemsInArray(
      [...this.#participatingElements.get(this.#draggingContainer)],
      move.moveFromIdx,
      move.moveToIdx
    );
    const elementsToAnimationInfo = (el) => {
      const selfRect = el.getBoundingClientRect();
      return {
        el,
        class: el.className,
        initialIdx: this.#participatingElements.get(this.#draggingContainer).findIndex((one) => one === el) ?? -1,
        finalIdx: itemsAfterDrop.findIndex((one) => one === el) ?? -1,
        xRel: 0,
        yRel: 0,
        x: 0,
        y: 0,
        width: selfRect.width,
        height: selfRect.height
      };
    };
    const initial = [...this.#participatingElements.get(this.#draggingContainer)].map(elementsToAnimationInfo);
    for (const [i, one] of initial.entries()) {
      const prevElDimensions = initial.filter((f, i2) => i2 < one.initialIdx).map((f) => f[dimension]).reduce((acc, val) => acc + val, 0);
      one[`${axis}Rel`] = (i + 1) * lineDimension + prevElDimensions;
      one[axis] = draggingContainerRect[axis] + one[`${axis}Rel`];
    }
    const final = itemsAfterDrop.map(elementsToAnimationInfo);
    for (const [i, one] of final.entries()) {
      const prevElDimensions = final.filter((f, i2) => i2 < one.finalIdx).map((f) => f[dimension]).reduce((acc, val) => acc + val, 0);
      one[`${axis}Rel`] = (i + 1) * lineDimension + prevElDimensions;
      one[axis] = draggingContainerRect[axis] + one[`${axis}Rel`];
    }
    return {
      initial,
      final
    };
  }
  #createDroppedElementAnimation(e, move) {
    this.#draggingElementShadow.style.visibility = "hidden";
    const axis = this.#draggingContainer.getAttribute("drag-orientation") === "horizontal" ? "x" : "y";
    const { final } = this.#getInitialAndFinalPositions(move, axis);
    const positions = {
      dragHandle: this.#draggingHandle.getBoundingClientRect(),
      draggingEl: this.#draggingElement.getBoundingClientRect(),
      targetFinal: final[move.moveToIdx]
    };
    const startFromLeft = e.clientX - (positions.dragHandle.left - positions.draggingEl.left);
    const startFromTop = e.clientY - (positions.dragHandle.top - positions.draggingEl.top);
    const startingStyle = {
      top: `${startFromTop}px`,
      left: `${startFromLeft}px`,
      opacity: ".8"
    };
    const endingStyle = {
      top: `${positions.targetFinal.yRel + this.#draggingContainer.getBoundingClientRect().y}px`,
      left: `${positions.targetFinal.xRel + this.#draggingContainer.getBoundingClientRect().x}px`,
      opacity: "1"
    };
    this.#draggingElementGhost.style.position = "fixed";
    this.#draggingElementGhost.style.zIndex = "1000";
    this.#draggingElementGhost.style.width = `${positions.draggingEl.width}px`;
    this.#draggingElementGhost.style.height = `${positions.draggingEl.height}px`;
    this.#draggingElementGhost.style.opacity = ".8";
    return this.#draggingElementGhost.animate([startingStyle, endingStyle], {
      duration: this.#animationDuration,
      easing: "cubic-bezier(0.42, 0, 0.58, 1)"
    }).finished;
  }
  #createMovedElementsAnimations(move, axis) {
    const { initial, final } = this.#getInitialAndFinalPositions(move, axis);
    const animations = [];
    for (let i = 0; i < initial.length; i++) {
      const initialEl = initial[i];
      const finalEl = final.find((one) => one.initialIdx === i);
      const startingStyle = {
        transform: `translate(0px,0px)`
      };
      const endingStyle = {
        transform: `translate(${axis === "x" ? `${finalEl.xRel - initialEl.xRel}px` : "0px"}, ${axis === "x" ? "0px" : `${finalEl.yRel - initialEl.yRel}px`})`
      };
      const animation = initial[i].el.animate([startingStyle, endingStyle], {
        duration: this.#animationDuration,
        easing: "cubic-bezier(0.42, 0, 0.58, 1)"
      }).finished;
      animations.push(animation);
    }
    return animations;
  }
  #animateDropped;
  get #isValidMove() {
    if (this.#dropContainerCandidate !== this.#draggingContainer) {
      return false;
    }
    if (!this.#dropTarget) {
      return false;
    }
    if (this.#noDropIdxs.includes(Number(this.#dropTarget.getAttribute("drag-idx")))) {
      return false;
    }
    const move = {
      container: this.#dropContainerCandidate,
      moveFromIdx: Number(this.#draggingElement.getAttribute("drag-idx")),
      moveToIdx: Number(this.#dropTarget.getAttribute("drag-idx"))
    };
    const dragChildren = this.#participatingElements.get(this.#draggingContainer);
    const isFirst = move.moveFromIdx === 0;
    const isLast = move.moveFromIdx === dragChildren.length;
    const isMiddle = !isFirst && !isLast;
    const isMovingDown = move.moveToIdx > move.moveFromIdx;
    if (isFirst) {
      move.moveToIdx = move.moveToIdx - 1;
    }
    if (isMiddle) {
      if (isMovingDown) {
        move.moveToIdx = move.moveToIdx - 1;
      }
    }
    if (isLast) {
      move.moveToIdx = move.moveToIdx + 1;
    }
    if (move.moveToIdx === move.moveFromIdx) {
      return false;
    }
    if (move.moveToIdx === -1) {
      return false;
    }
    return move;
  }
  #makeDropTargetLine;
  #handleMouseDown;
  #registerParticipatingElements(dragContainers) {
    dragContainers.forEach((dragContainer) => {
      dragContainer.addEventListener("pointerdown", this.#handlePointerDown);
      dragContainer.addEventListener("mousedown", this.#handleMouseDown);
      dragContainer.addEventListener("dragenter", this.#handleDragEnter);
      dragContainer.addEventListener("dragleave", this.#handleDragLeave);
      dragContainer.addEventListener("pointerup", this.#handlePointerUp);
      const draggableItems = [...dragContainer.children];
      this.#participatingElements.set(dragContainer, draggableItems);
      draggableItems.forEach((child, idx) => {
        const target = this.#makeDropTargetLine(dragContainer, idx);
        dragContainer.insertBefore(target, child);
        this.#dropTargetLines.push(target);
        if (idx + 1 === draggableItems.length) {
          const lastTarget = this.#makeDropTargetLine(dragContainer, idx + 1);
          dragContainer.appendChild(lastTarget);
          this.#dropTargetLines.push(lastTarget);
        }
      });
    });
    this.#log("participating elements registered", this.#participatingElements);
  }
  #unregisterParticipatingElements() {
    this.#participatingElements.forEach((child, dragContainer) => {
      dragContainer.removeEventListener("pointerdown", this.#handlePointerDown);
      dragContainer.removeEventListener("mousedown", this.#handleMouseDown);
      dragContainer.removeEventListener("pointerup", this.#handlePointerUp);
      dragContainer.removeEventListener("dragenter", this.#handleDragEnter);
      dragContainer.removeEventListener("dragleave", this.#handleDragLeave);
      this.#pointerEventHandled = false;
    });
    this.#participatingElements.clear();
    this.#dropTargetLines.forEach((targetEl) => {
      targetEl.remove();
    });
    this.#dropTargetLines = [];
    this.#host.shadowRoot.querySelectorAll("[drag-and-drop-clone]").forEach((one) => one.remove());
    this.#draggingHandle = null;
    this.#draggingContainer = null;
    this.#draggingElement = null;
    this.#draggingElementShadow = null;
    this.#draggingElementGhost = null;
    this.#dropTarget = null;
    this.#log("participating elements unregistered", this.#participatingElements);
  }
}
const moveItemsInArray = (array, moveFromIdx, moveToIdx) => {
  const itemToMove = array[moveFromIdx];
  array.splice(moveFromIdx, 1);
  array.splice(moveToIdx, 0, itemToMove);
  return array;
};
const LINE_STYLES = `
  :host {
    --drop-line-color: var(--color-primary);
    --drop-line-stroke: 2px;
    --drop-line-padding: 0.5rem;
    --drop-line-extend: 10px;
    --drop-line-dragging-padding: 1.5rem;
  }
  [drop-line-container] {
    position: relative;
    height: 100%;
    padding: var(--drop-line-padding) 0;
    margin: 0 calc(-1 * var(--drop-line-extend));
    flex-grow: 1;
  }
  [dragging] [drop-line-container] {
    padding: calc(var(--drop-line-padding) + var(--drop-line-dragging-padding)) 0;
    margin: calc(-1 * var(--drop-line-dragging-padding)) calc(-1 * var(--drop-line-extend));
  }
  [drag-orientation='horizontal'] [drop-line-container] {
    padding: 0 var(--drop-line-padding);
    margin: calc(-1 * var(--drop-line-extend)) 0;
  }
  [dragging][drag-orientation='horizontal'] [drop-line-container] {
    padding: 0 calc(var(--drop-line-padding) + var(--drop-line-dragging-padding));
    margin: calc(-1 * var(--drop-line-extend)) calc(-1 * var(--drop-line-dragging-padding));
  }
  [drop-line] {
    background-color: transparent;
    height: var(--drop-line-stroke);
    width: 100%;
  }
  [drag-over] [drop-line] {
    background-color: var(--drop-line-color);
  }

  [drag-orientation='horizontal'] [drop-line] {
    height: 100%;
    width: var(--drop-line-stroke);
  }
  [dot] {
    position: absolute;
    width: 6px;
    height: 6px;
    border-radius: 50%;
  }
  [dot-one] {
    left: 0;
    top: 50%;
    transform: translate(-50%, -50%);
  }
  [dot-two] {
    right: 0;
    top: 50%;
    transform: translate(50%, -50%);
  }
  [drag-over] [dot] {
    background-color: var(--drop-line-color);
  }
  [drag-orientation='horizontal'] [dot-one] {
    top: 0;
    left: 50%;
    transform: translate(-50%, -50%);
  }
  [drag-orientation='horizontal'] [dot-two] {
    top: unset;
    bottom: 0;
    left: 50%;
    transform: translate(-50%, 50%);
  }
`;
export {
  DragAndDropController,
  moveItemsInArray
};
//# sourceMappingURL=drag-and-drop-controller.js.map
