class DraggableController {
  constructor(host, noDragSelector, positionThroughCssProperties = false) {
    this.isDragging = false;
    this.startX = 0;
    this.startY = 0;
    this.eleRefs = [];
    this.secondaryEvents = ["mouseleave", "mouseup", "pointerup", "pointerleave", "pointercancel"];
    this.#updateCursorState = (e) => {
      const path = e.composedPath();
      this.eleRefs.forEach((ele) => {
        if (path.includes(ele)) {
          ele.style.cursor = "default";
        } else {
          ele.style.cursor = "grab";
        }
      });
    };
    this.#handlePointerDown = (e) => {
      this.isDragging = true;
      this.startX = e.clientX - this.host.offsetLeft;
      this.startY = e.clientY - this.host.offsetTop;
      this.host.style.cursor = "grabbing";
      document.addEventListener("pointermove", this.#handlePointerMove);
      this.secondaryEvents.forEach((event) => {
        document.addEventListener(event, this.#handlePointerUp);
      });
      this.#originalBodyStyle = document.body.style.cssText;
      this.#emitDragEvent("dragstart", e);
    };
    this.#handlePointerMove = (e) => {
      if (!this.isDragging)
        return;
      document.body.style.cursor = "grabbing";
      document.body.style.userSelect = "none";
      document.body.style["-webkit-user-select"] = "none";
      const { width, height } = this.host.getBoundingClientRect();
      const left = e.clientX - this.startX;
      const top = e.clientY - this.startY;
      if (!this.#positionThroughCssProperties) {
        this.host.style.left = `${left}px`;
        this.host.style.top = `${top}px`;
      } else {
        this.host.style.setProperty("--drag-left", `${Math.round(left)}px`);
        this.host.style.setProperty("--drag-top", `${Math.round(top)}px`);
        this.host.style.setProperty("--drag-width", `${Math.round(width)}px`);
        this.host.style.setProperty("--drag-height", `${Math.round(height)}px`);
      }
      this.#emitDragEvent("drag", e);
    };
    this.#handlePointerUp = () => {
      this.isDragging = false;
      this.host.style.cursor = "grab";
      document.removeEventListener("pointermove", this.#handlePointerMove);
      this.secondaryEvents.forEach((event) => {
        document.removeEventListener(event, this.#handlePointerUp);
      });
      document.body.style.cssText = this.#originalBodyStyle;
      this.#emitDragEvent("dragend");
    };
    /**
     * emits events to communicate movements to host and outside listeners.
     * A breaking change could remove this as it is mainly to keep the same functionality as the DraggableMixin used on OmniTile
     */
    this.#emitDragEvent = (name, e = null) => {
      const { pageX, pageY } = e ?? { pageX: 0, pageY: 0 };
      const { left, top, width, height } = this.host.getBoundingClientRect();
      const offsetX = pageX - left;
      const offsetY = pageY - top;
      const { innerWidth, innerHeight } = window;
      const currPosition = {
        left,
        top,
        width,
        height,
        offsetX,
        offsetY,
        availableWidth: innerWidth,
        availableHeight: innerHeight
      };
      this.host.dispatchEvent(new CustomEvent(name, { bubbles: true, composed: true, detail: currPosition }));
    };
    this.host = host;
    this.host.addController(this);
    this.#noDragSelectors = noDragSelector ?? [];
    this.#positionThroughCssProperties = positionThroughCssProperties;
  }
  #noDragSelectors;
  #originalBodyStyle;
  /** position with the css properties found in the draggable mixin */
  #positionThroughCssProperties;
  #stopPropagationForElements(e) {
    e.stopPropagation();
  }
  #updateCursorState;
  async hostConnected() {
    this.host.addEventListener("pointerdown", this.#handlePointerDown);
    await this.host.updateComplete;
    this.#noDragSelectors.forEach((selector) => {
      const elements = this.host.shadowRoot.querySelectorAll(selector);
      this.eleRefs.push(...elements);
      elements.forEach((element) => {
        element.addEventListener("mouseover", this.#updateCursorState);
        element.addEventListener("pointerdown", this.#stopPropagationForElements);
      });
    });
  }
  hostDisconnected() {
    this.host.removeEventListener("pointerdown", this.#handlePointerDown);
    this.#noDragSelectors.forEach((selector) => {
      const elements = this.host.querySelectorAll(selector);
      elements.forEach((element) => {
        element.removeEventListener("mouseover", this.#updateCursorState);
        element.removeEventListener("pointerdown", this.#stopPropagationForElements);
      });
    });
  }
  #handlePointerDown;
  #handlePointerMove;
  #handlePointerUp;
  #emitDragEvent;
}
export {
  DraggableController
};
//# sourceMappingURL=draggable-controller.js.map
