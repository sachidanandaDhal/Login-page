var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
import { html, nothing } from "lit";
import { property, state, query } from "lit/decorators.js";
import { OmniElement } from "../../omni-element.js";
import "../omni-progress-bar/omni-progress-bar.js";
import { css } from "lit";
const styles = css`:host{overflow:visible;position:relative;z-index:999;top:0;bottom:0;left:0;right:0}.modal-container{display:flex;flex-direction:column;align-items:center;justify-content:center;position:fixed;top:0;bottom:0;left:0;right:0}section.backdrop{position:fixed;top:0;bottom:0;left:0;right:0;background-color:#3b3e3f;opacity:.5;z-index:1000;cursor:default}section.body{position:relative;z-index:1001;width:479px;padding:40px;border:1px solid #edf0f4;border-radius:10px;background-color:#fff;display:flex;flex-direction:column;justify-content:center}section.body span.step{font-size:14px;font-weight:600;font-stretch:normal;font-style:normal;line-height:normal;letter-spacing:.31px;color:#3b3e3f;margin-bottom:20px}section.body div.bars{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}section.body div.bars omni-progress-bar{flex-grow:1;margin:0 5px}section.body span.info{font-size:14px;font-weight:normal;font-stretch:normal;font-style:normal;line-height:normal;letter-spacing:.31px;color:#a2a9ad;text-align:center}section.body ::slotted(div[slot=buttons]){margin-top:16px;display:flex;justify-content:end}`;
class OmniModalProgress extends OmniElement {
  constructor() {
    super(...arguments);
    this.activeStepIdx = 0;
    this.elapsed = 0;
    this.progress = [];
    this.isRollingToComplete = false;
    this.slottedMessageExists = false;
    this.estimatedTime = 30;
    this.steps = [];
    this.showcountdown = false;
  }
  static get styles() {
    return [...super.styles, styles];
  }
  #stepInterval;
  #elapsedInterval;
  connectedCallback() {
    super.connectedCallback();
    this.progress = new Array(this.steps.length).fill(0);
    this.#elapsedInterval = setInterval(() => {
      this.elapsed = this.elapsed + 1;
      if (this.elapsed >= this.estimatedTime) {
        clearInterval(this.#elapsedInterval);
      }
    }, 1e3);
    this.moveToStep(0);
  }
  moveToStep(idx) {
    this.activeStepIdx = idx;
    const intervalStepPeriod = 100;
    const stepsToMake100 = this.estimatedTime * this.steps[idx].ratio * 100 * (intervalStepPeriod / 1e3);
    this.#stepInterval = setInterval(() => {
      this.progress[idx] += intervalStepPeriod / stepsToMake100;
      this.requestUpdate();
      if (this.progress[idx] > 100) {
        clearInterval(this.#stepInterval);
        if (this.steps[idx + 1]) {
          this.moveToStep(idx + 1);
        }
      }
    }, intervalStepPeriod);
  }
  async rollToComplete() {
    this.isRollingToComplete = true;
    clearInterval(this.#stepInterval);
    this.elapsed = this.estimatedTime - 1;
    const timeout = (timeoutMs) => new Promise((resolve) => setTimeout(resolve, timeoutMs));
    for (const idx in this.steps) {
      if (this.progress[idx] < 100) {
        this.progress[idx] = 100;
        this.requestUpdate();
        await timeout(500);
      }
    }
    clearInterval(this.#elapsedInterval);
  }
  render() {
    const remaining = this.estimatedTime - this.elapsed;
    const countdown = this.showcountdown ? `About ${remaining} second${remaining > 1 ? "s" : ""} remaining.` : nothing;
    const countdownPadding = this.slottedMessageExists ? "margin-top: 8px" : "margin-top: 24px";
    return html`
      <omni-style>
        <div class="modal-container">
          <section class="backdrop"></section>
          <section class="body">
            <span class="step"> ${this.steps[this.activeStepIdx].text} </span>
            <div class="bars">
              ${this.steps.map(
      (step, idx) => html` <omni-progress-bar .value=${this.progress[idx]}></omni-progress-bar> `
    )}
            </div>
            <slot name="message" @slotchange=${() => this.slottedMessageExists = true}></slot>
            <span class="info" style="${countdownPadding}">
              ${remaining > 0 ? countdown : !this.isRollingToComplete ? "This is taking longer than expected" : countdown}
            </span>
            <slot name="buttons"></slot>
          </section>
        </div>
      </omni-style>
    `;
  }
}
__decorateClass([
  state()
], OmniModalProgress.prototype, "activeStepIdx", 2);
__decorateClass([
  state()
], OmniModalProgress.prototype, "elapsed", 2);
__decorateClass([
  state()
], OmniModalProgress.prototype, "progress", 2);
__decorateClass([
  state()
], OmniModalProgress.prototype, "isRollingToComplete", 2);
__decorateClass([
  state()
], OmniModalProgress.prototype, "slottedMessageExists", 2);
__decorateClass([
  property({ type: Number })
], OmniModalProgress.prototype, "estimatedTime", 2);
__decorateClass([
  property({ type: Array })
], OmniModalProgress.prototype, "steps", 2);
__decorateClass([
  property({ type: Boolean, attribute: true })
], OmniModalProgress.prototype, "showcountdown", 2);
__decorateClass([
  query(".body")
], OmniModalProgress.prototype, "modalBody", 2);
OmniElement.register("omni-modal-progress", OmniModalProgress);
export {
  OmniModalProgress
};
//# sourceMappingURL=omni-modal-progress.js.map
