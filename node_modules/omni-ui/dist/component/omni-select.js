import { html, css } from "lit";
import { OmniFormControl } from "../omni-form-control.js";
import "./omni-origin/omni-origin.js";
import "./omni-icon/omni-icon.js";
import "./omni-option.js";
import "./omni-optgroup.js";
class OmniSelect extends OmniFormControl {
  formResetCallback() {
    const { options, _originalOptions } = this;
    options.forEach((option) => {
      const { index } = option;
      option.selected = _originalOptions.has(index);
    }, this);
    this.firstUpdated();
  }
  /* formStateRestoreCallback callback when client restores
  	to trigger submit the form and hit the browser back button (mode='restore') or enable mode="autocomplete" (mode='autocomplete'
  	WIP TODO this is incomplete
  	@state {any} state - value sent
  	 @see {@link https://html.spec.whatwg.org/multipage/custom-elements.html} reference spec
  Chrome currently doesn't handle autofill for form-associated
  custom elements. In the autofill case, you might need to handle a raw value.
  	@param {string} mode - 'restore' (submit then go back) or 'autocomplete'
   */
  formStateRestoreCallback(state, mode) {
    this.setValidity();
    if (mode === "restore") {
      const [controlMode, value] = state.split("/");
      this._mode = `${controlMode}/${value}`;
    }
  }
  formAssociatedCallback(form) {
    this.form === form;
    this.setValidity();
  }
  static get properties() {
    return {
      _size: { type: Number },
      disabled: { type: Boolean, reflect: true },
      /*
      @see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select#usage_notes} Selecting multiple behavior
      */
      open: { type: Boolean, reflect: true },
      multiple: { type: Boolean, reflect: true },
      required: { type: Boolean, reflect: true },
      /* @prop size default: 0 as in not-set and interpreted as lines to show: 1 or with multiple 4 lines;
       */
      size: {
        type: Number,
        reflect: true,
        converter: {
          // remove if not truthy
          toAttribute(value) {
            return value || void 0;
          }
        }
      }
    };
  }
  constructor() {
    super();
    this.addEventListener("click", this._click);
    this._closing = this._closing.bind(this);
    this._opening = this._opening.bind(this);
    this.addEventListener("overlay-remove", this._closing);
    this.addEventListener("overlay", this._opening);
    this.addEventListener("option", this._option);
    this.addEventListener("focus", this._focus);
    this.__observer = new MutationObserver(this._mutationCallback.bind(this));
    this.setAttribute("init", "");
    this.addEventListener("invalid", this._invalid);
    this.addEventListener("input", this._remit);
    this.addEventListener("change", this._remit);
    console.warn(
      "OmniSelect is deprecated and will be removed in the upcoming Omni-UI 8.0 release. Please use OmniDropdown instead. https://omni-ui.annalect.com/dropdown"
    );
  }
  _selection({ detail } = {}) {
    if (!this.matches("omni-select:not([multiple])")) {
      return;
    }
    const option = detail && detail.matches("omni-option") ? detail : this.querySelector("omni-option[selected]") || this.querySelector("omni-option");
    if (!option)
      return;
    requestAnimationFrame(() => {
      this.shadowRoot.querySelector("section").scrollTop = option.offsetTop;
    });
  }
  /* when this element is in the overlay, and not in the original context (eg a form)
  this listener will re-emit the event on the origin element in that context,
  omni-dropdown and any similar scenario uses this */
  _remit(event) {
    if (this === event.target && this.matches("omni-overlay > *")) {
      const { type, bubbles, cancelable, composed, detail } = event;
      this.origin.dispatchEvent(new CustomEvent(type, { bubbles, cancelable, composed, detail }));
    }
    this._selection(event);
  }
  _mutationCallback(mutations, observer) {
    cancelAnimationFrame(this.__mutated);
    this.__mutated = requestAnimationFrame(() => {
      this._index();
      this.dispatchEvent(new CustomEvent("mutation", { detail: mutations }));
    });
  }
  _invalid() {
    this.removeAttribute("init");
  }
  /*
  retrieve and tranform values in this component to primitives expected for consumption
  ie passing it to URLSearchParams and other in-transit/payload related next-steps (in the DOM or over HTTP, etc)
  @returns {array} array of zero or more option-value strings
  */
  get value() {
    return Array.from(this.selectedOptions).map((option) => option.value);
  }
  setValidity() {
    const values = this.value.filter((val) => !!val.trim());
    if (!this.matches(":disabled") && this.required && !values.length) {
      this.internals.setValidity({ valueMissing: true }, "Selection required.");
    } else {
      this.internals.setValidity({});
    }
    this.setFormValue(values);
  }
  setFormValue(values) {
    this.internals.setFormValue(values);
  }
  _option({ target }) {
    cancelAnimationFrame(this._setvalidity);
    this._setvalidity = requestAnimationFrame(() => {
      this.setValidity();
    });
  }
  connectedCallback() {
    super.connectedCallback();
    this.__observer.observe(this, { childList: true, subtree: true });
    if (!this.hasAttribute("role")) {
      this.setAttribute("role", "combobox");
    }
    let { origin } = this;
    if (!origin) {
      origin = this.ownerDocument.createElement("omni-origin");
      origin.target = this;
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__observer.disconnect();
  }
  willUpdate(changedProperties) {
    if (changedProperties.has("size")) {
      const size = Number(this.size || 0);
      if (!isNaN(size) && size > 0) {
        this._size = size;
      }
    }
  }
  _position() {
    const { style, origin } = this;
    const { x, y, width, height } = this.getBoundingClientRect();
    const computed = getComputedStyle(this);
    const { clientWidth, clientHeight } = this.ownerDocument.documentElement;
    const { scrollWidth, scrollHeight } = this.shadowRoot.querySelector("section");
    let offsetLeft = "- 2px";
    let offsetTop = "- 2px";
    let [left, top] = [x, y];
    const [useWidth, useHeight] = this.multiple ? [width, height] : [scrollWidth, scrollHeight];
    if (left + useWidth > clientWidth) {
      left = clientWidth - useWidth;
      offsetLeft = "- 1rem";
      if (left < 1) {
        offsetLeft = "+ 1rem";
        left = 0;
      }
    }
    if (top + useHeight > clientHeight) {
      offsetTop = "- 1rem";
      top = clientHeight - useHeight;
      if (top < 1) {
        offsetTop = "+ 1rem";
        top = 0;
      }
    }
    const originstyle = origin.style;
    originstyle.setProperty("display", computed.display);
    originstyle.setProperty("position", computed.position);
    originstyle.setProperty("width", `calc(${width}px + 3px)`);
    originstyle.setProperty("height", `calc(${height}px - 2px)`);
    originstyle.setProperty("visibility", `hidden`);
    style.setProperty("--open-height", `${Math.round(useHeight)}px`);
    style.setProperty("--open-width", `${Math.round(useWidth)}px`);
    style.setProperty("--open-left", `calc(${Math.round(left)}px ${offsetLeft})`);
    style.setProperty("--open-top", `calc(${Math.round(top)}px ${offsetTop})`);
  }
  /*
  returns base 0 index of first selected option, including for multiple
  default: 0 || -1 with multiple
  */
  get selectedIndex() {
    const { selectedOptions } = this;
    if (!selectedOptions.length) {
      return -1;
    }
    return selectedOptions[0].index;
  }
  /*	this.selectedIndex returns the input param
  @param {number} the base 0 index for an option
  @prop {number} last selected index
  @returns {number} base 0 inex for last [selected] option, or first or -1 when none present
  */
  set selectedIndex(index) {
    if (!isNaN(index)) {
      const { options } = this;
      let node;
      if (index < 0 || index >= options.length) {
        if (!this.multiple) {
          node = options[this.selectedIndex];
          node.selected = false;
          node = options[this._originalOptions.values().next().value];
          node.selected = true;
        } else {
          let i = 0;
          for (; node = options[i]; i++) {
            node.selected = false;
          }
        }
      } else if (!this.multiple) {
        node = options[this.selectedIndex];
        node.selected = false;
        options[index].selected = true;
      } else {
        options[index].selected = true;
      }
    }
  }
  /* this.selectedOptions
  @prop {object}
  @returns all selected options as NodeList
  */
  get selectedOptions() {
    return this.querySelectorAll("omni-option[selected], option[selected]");
  }
  _indexEach(node, i) {
    node._index = i;
    return node;
  }
  _index() {
    const options = Array.from(this.options);
    options.forEach(this._indexEach);
    return options;
  }
  /* this.options emulate HTMLOptionsCollection
  @prop {object}
  @return NodeList of options with selectedIndex property for currently selected option's index
  @example this.options // [omni-option, omni-option, selectedIndex: 1]
  */
  get options() {
    return this.querySelectorAll("omni-option, option");
  }
  _closing(event) {
    requestAnimationFrame(() => {
      this.removeAttribute("init");
      this.removeAttribute("open");
      this.slot = this.__slot ?? "";
      const { origin } = this;
      origin.style.setProperty("display", "none");
      if (origin.nextElementSibling !== this) {
        origin.after(this);
      }
    });
  }
  _opening(event) {
    this.open = true;
    this.__slot = this.slot;
    this.slot = "form";
    this._position();
  }
  _click(event) {
    const { target } = event;
    const { multiple, open } = this;
    if (multiple) {
      this._change(event);
    } else {
      if (open) {
        if (!target.assignedSlot?.name) {
          this._change(event);
        }
        if (!multiple) {
          this.dispatchEvent(new CustomEvent("overlay-remove", { detail: this, bubbles: true, composed: true }));
        }
      } else {
        this.dispatchEvent(new CustomEvent("overlay", { detail: this, bubbles: true, composed: true }));
      }
    }
  }
  firstUpdated() {
    const options = this._index();
    if (!this._originalOptions) {
      const { selectedOptions } = this;
      let selected = Array.from(selectedOptions);
      if (!selectedOptions.length && !this.multiple && options.length) {
        let node = options.find((node2) => node2.defaultSelected);
        if (!node) {
          node = options[0];
        }
        node.selected = true;
        selected = [node];
      }
      this._originalOptions = new Set(selected.map((option) => option.index));
    }
    requestAnimationFrame(() => {
      this._selection();
    });
  }
  __deselect(node) {
    if (this.index === node.index) {
      return;
    }
    node.selected = false;
  }
  _change(event) {
    const [option, optgroup] = this.pathfinder(event, "omni-option, option, optgroup, omni-optgroup", true);
    if (!option || !option.matches("omni-option,option")) {
      return;
    }
    let { index } = option;
    const isOptgroup = option.hasAttribute("optgroup");
    const disabled = option.closest("[disabled]");
    if (isOptgroup) {
      index = optgroup.querySelector(":scope > omni-option").index;
    }
    if (disabled) {
      return;
    }
    if (!this.multiple && (option.selected || isOptgroup)) {
      return;
    }
    option.toggleAttribute("selected");
    if (isOptgroup) {
      const selected = option.hasAttribute("selected");
      option.getRootNode().host.toggle(selected);
    }
    if (!this.multiple && option.selected) {
      this.selectedOptions.forEach(this.__deselect, { index });
    }
    requestAnimationFrame(() => {
      this.dispatchEvent(
        new CustomEvent("input", {
          bubbles: true,
          cancelable: false,
          composed: true,
          detail: option
        })
      );
      this.dispatchEvent(
        new CustomEvent("change", {
          bubbles: true,
          cancelable: false,
          composed: false,
          detail: option
        })
      );
    });
  }
  static get styles() {
    return [
      ...super.styles,
      css`
        :host {
          contain: paint;
          content-visibility: auto;
          --option-hover: transparent;
          --icon-color: var(--color-electric-blue);
          --icon-size: 1em;
          --icon-bg: transparent;
          --icon-bg-selected: transparent;
          --icon-border: transparent;
          --icon-border-selected: transparent;
          --icon-margin: 0.2em 0.1em 0.1em 0.2em;
          --icon-border-disabled: transparent;
          --padding: 0.3em 1.6em 0.2em 0.5em;
          --padding-adjust: 0.1em;
          --optgroup-first-icon: none;
          display: inline-block;
          box-sizing: border-box;
          border: thin solid var(--bg-color, #555);
          margin: 0.1rem;
          cursor: pointer;
          appearance: none;
          align-items: center;
          border-radius: var(--radius-small, 0.3em);
          box-shadow: none;
          box-sizing: border-box;
          font-size: 1em;
          justify-content: flex-start;
          line-height: 1.5;
          position: relative;
          vertical-align: top;
          outline: none;
          color: var(--color);
          --option-size: 2.4em;
          --option-count: 1;
          height: calc(var(--option-size) * var(--option-count));
        }
        :host(omni-select[multiple]) {
          --option-count: 4;
        }
        :host([multiple]) {
          --inactive-display: flex;
          --icon-color: #fff;
          --icon-bg: none;
          --icon-bg-selected: var(--gradient-electric-blue);
          --icon-border: #555;
          --icon-border-selected: var(--gradient-electric-blue);
          --padding: 0.3em 0.5em 0.2em 0.2em;
          --padding-adjust: 0.2em;
          --icon-margin: 0.22em 0.3em 0.1em 0.3em;
          --icon-size: 0.8em;
          --icon-border-disabled: #aaa;
          --optgroup-first-icon: block;
        }
        :host([disabled][multiple]) {
          --icon-border: var(--color-disabled);
        }
        :host(:where(:active, :focus, :focus-within, :hover):not([disabled])) {
          background-color: #fff;
          --option-hover: #d6f5fc;
          max-height: calc(100vh - 2rem) !important;
          max-width: calc(100vw - 2rem) !important;
        }
        :host(omni-select:not([disabled]):active) {
          border-color: var(--color-electric-blue);
          box-shadow: var(--bulma-shadow-1);
        }
        :host(:hover) {
          border-color: var(--color-gray-b5);
        }
        :host(omni-select:not([disabled]):focus) {
          border-color: var(--color-electric-blue);
          box-shadow: var(--bulma-shadow-1);
        }
        :host(:is([open])),
        :host(:not([disabled]):focus-visible) {
          outline: 0.125em var(--blue);
          box-shadow: 0 0 0 0.125em var(--blue) !important;
        }
        /* TODO remove?
				:host(:not([multiple]):not([active])) {
					--inactive-options: none;
				}
*/
        :host([disabled]) {
          background-color: transparent;
          border-color: var(--color-gray-b5);
          box-shadow: none;
          cursor: not-allowed;
        }
        :host([disabled]) section:focus-visible {
          outline: none;
          pointer-events: none;
        }
        /* icon */
        section {
          display: flex;
          overflow: hidden;
          height: 100%;
          box-sizing: border-box;
        }
        :host(:where([open], omni-select[multiple]):where(:active, :focus, :focus-within, :hover):not([disabled]))
          section {
          overflow: auto;
        }
        [options] {
          padding: 0;
          display: flex;
          flex-direction: column;
        }
        :host(omni-select[multiple]) [icon] {
          display: none;
        }
        [icon] {
          direction: rtl;
          pointer-events: none;
          position: absolute;
          inset: 0 0 auto auto;
        }
        [icon] omni-icon {
          width: 1em;
          padding: 0.6em 0.5em;
          transform: rotate(0);
        }
        :host([open]) [icon] omni-icon,
        :host(omni-select[open]) [icon] omni-icon {
          transform: rotate(-180deg);
        }
        /* align on other edge, more on :dir at
					https://developer.mozilla.org/docs/Web/CSS/:dir
					https://www.chromestatus.com/features/5751531651465216
				 */
        :dir(rtl) [icon] {
          direction: ltr;
        }
        :host(:not(:is([init], [open], [disabled])):is([aria-invalid='true'], [internals-invalid], :invalid)) {
          border-color: var(--error-color, red);
        }

        :host([open][style]) {
          width: var(--open-width);
          height: var(--open-height);
          top: var(--open-top);
          left: var(--open-left);
        }
      `
    ];
  }
  render() {
    return html`
      <style>
        ${this._size ? `
				:host([size]){
			--option-count:${this._size};
				}
				` : ""}
      </style>
      <section tabindex=${this.disabled ? -1 : 0}>
        <div options>
          <slot></slot>
        </div>
        <div icon>
          <omni-icon class="is-size-1" icon-id="omni:interactive:down"></omni-icon>
        </div>
      </section>
    `;
  }
}
OmniSelect.register("omni-select", OmniSelect);
export {
  OmniSelect
};
//# sourceMappingURL=omni-select.js.map
