var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
import { html, nothing } from "lit";
import { ifDefined } from "lit-html/directives/if-defined.js";
import { property, queryAsync, state } from "lit/decorators.js";
import { styleMap } from "lit/directives/style-map.js";
import { OmniElement } from "../../omni-element.js";
import { debounce } from "../../omni-util.js";
import { OmniTableElement } from "../omni-table/omni-table.js";
OmniTableElement.register();
import { css } from "lit";
const styles = css`:host{position:relative;background-color:#f5f8fb}:host([stickyside=right]){padding-left:1.2rem}:host([stickyside=left]){padding-right:1.2rem}.scroll-container{display:flex;position:relative;overflow:auto visible}omni-table{overflow:visible}omni-table::part(table){overflow:visible}omni-table::part(table-container){overflow:visible}.scroll-table{box-sizing:content-box;flex:0 0 100%;position:relative;z-index:1}.scroll-table.left::part(table){padding-right:0 !important;padding-left:0 !important}.scroll-table.left::part(table-body-row):hover{border-radius:0;transform:none !important}.scroll-table.left::part(td){border-top-right-radius:0;border-bottom-right-radius:0;border-right:none !important}.scroll-table.right::part(table){padding-left:0 !important;padding-right:0 !important}.scroll-table.right::part(table-body-row):hover{border-radius:0;transform:none !important}.scroll-table.right::part(td){border-top-left-radius:0;border-bottom-left-radius:0;border-left:0 !important}.sticky-table{position:absolute;top:0;z-index:2}.sticky-table.left{left:0;border-right:2px solid #f1f5fa}.sticky-table.left.shadow{clip-path:polygon(105% 0, 105% 100%, 0 100%, 0 0);box-shadow:rgba(10,10,10,.15) 5px 0 8px}.sticky-table.left::part(table){padding-right:0 !important}.sticky-table.left::part(table-body-row):hover{border-radius:0;transform:none !important}.sticky-table.left::part(td){border-top-right-radius:0;border-bottom-right-radius:0;border-right:none !important}.sticky-table.right{right:0;border-left:2px solid #f1f5fa}.sticky-table.right.shadow{clip-path:polygon(100% 0, 100% 100%, -5% 100%, -5% 0);box-shadow:-5px 0 8px rgba(10,10,10,.15)}.sticky-table.right::part(table){padding-left:0 !important}.sticky-table.right::part(table-body-row):hover{border-radius:0;transform:none !important}.sticky-table.right::part(td){border-top-left-radius:0;border-bottom-left-radius:0;border-left:0 !important}.sticky-scrollbar-container{display:block;bottom:0;z-index:3;overflow-x:scroll}.sticky-scrollbar-container .overflow{height:1px}.sticky-scrollbar-container::-webkit-scrollbar{height:14px;border-top:1px solid #e8e8e8;border-bottom:1px solid #e8e8e8;background:#fafafa}.sticky-scrollbar-container::-webkit-scrollbar-track{background-color:rgba(0,0,0,0)}.sticky-scrollbar-container::-webkit-scrollbar-thumb{background-color:#c7c7c7;border-radius:7px;height:14px;border:3px solid rgba(0,0,0,0);background-clip:padding-box}.sticky-scrollbar-container::-webkit-scrollbar-thumb:hover{background-color:#878787}`;
class OmniTableSticky extends OmniElement {
  constructor() {
    super();
    this._shouldShowShadow = false;
    this._scrollTablePadding = 0;
    this._stickyScrollbarStyles = {
      width: "100%",
      height: "auto",
      position: "absolute",
      "overflow-x": "auto"
    };
    this._stickyScrollBarOverflowWidth = 0;
    this.stickySide = "right";
    this.leftColumns = [];
    this.rightColumns = [];
    this.stickyScrollbar = false;
    this.data = [];
    this.sort = {};
    this.expandAllOnLoad = false;
    this.hideNestedIndent = false;
    /**
     * * the default must include both column configs in order to keep tracking in sync between the two tables
     * * for example, `isMain` is included on the left columns, and not the right, but we want to key off of `isMain` for both
     */
    this.#defaultKeyFn = (row) => {
      const bothColumns = [...this.leftColumns, ...this.rightColumns];
      const isMainKey = bothColumns.find((one) => one.isMain)?.key;
      const firstColumnKey = bothColumns.find((one) => one.key)?.key;
      return row[isMainKey] ?? row[firstColumnKey] ?? row;
    };
    /** debounced shadow hide after scrolling is stopped */
    this.#hideShadow = debounce(() => {
      this._shouldShowShadow = false;
    }, 350);
    this.#wrapWithScrollContainer = (el) => html`
    <div class="scroll-container ${this.stickySide}" @scroll=${this.#handleScrollContainerScroll}>${el}</div>
  `;
    this.#defaultTable = (columns = []) => html`
    <omni-table
      class="table"
      .columns=${columns}
      .data=${this.data}
      .sort=${this.sort}
      .keyFn=${this.keyFn}
      nestedIndent=${ifDefined(this.nestedIndent)}
      .expandAllOnLoad=${this.expandAllOnLoad}>
    </omni-table>
  `;
    this.#leftTable = (cssClasses = "") => html`
    <omni-table
      id="left-table"
      class="${cssClasses} ${this._shouldShowShadow ? "shadow" : ""}"
      style=${this.stickySide === "right" ? `padding-right: ${this._scrollTablePadding}px` : ""}
      .columns=${this.leftColumns}
      .data=${this.data}
      .sort=${this.sort}
      .keyFn=${this.keyFn}
      nestedIndent=${ifDefined(this.nestedIndent)}
      .expandAllOnLoad=${this.expandAllOnLoad}
      @hover-row-enter=${({ detail }) => {
      this._rightTableEl.then((el) => el.hoverRow(detail));
    }}
      @hover-row-exit=${({ detail }) => {
      this._rightTableEl.then((el) => el.removeHoverRow(detail));
    }}
      @expand-or-collapse-rows=${({ detail }) => {
      this._rightTableEl.then((el) => el.toggleRowExpansion(detail));
      this.#calcScrollTablePadding();
    }}>
    </omni-table>
  `;
    this.#rightTable = (cssClasses = "") => html`
    <omni-table
      id="right-table"
      class="${cssClasses} ${this._shouldShowShadow ? "shadow" : ""}"
      style=${this.stickySide === "left" ? `padding-left: ${this._scrollTablePadding}px` : ""}
      .columns=${this.rightColumns}
      .data=${this.data}
      .sort=${this.sort}
      .keyFn=${this.keyFn}
      .hideNestedIndent=${true}
      .expandAllOnLoad=${this.expandAllOnLoad}
      @hover-row-enter=${({ detail }) => {
      this._leftTableEl.then((el) => el.hoverRow(detail));
    }}
      @hover-row-exit=${({ detail }) => {
      this._leftTableEl.then((el) => el.removeHoverRow(detail));
    }}
      @expand-or-collapse-rows=${({ detail }) => {
      this._leftTableEl.then((el) => el.toggleRowExpansion(detail));
      this.#calcScrollTablePadding();
    }}>
    </omni-table>
  `;
    this.keyFn = this.#defaultKeyFn;
  }
  static get styles() {
    return [...super.styles, styles];
  }
  #intersectionObserver;
  #resizeObserver;
  #defaultKeyFn;
  firstUpdated() {
    this.#calcScrollTablePadding();
    if (this.stickyScrollbar) {
      this.#calcStickyScrollbarContainerWidth();
      let isTopVisible = false;
      let isBottomVisible = false;
      let isThisVisible = false;
      this.#intersectionObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.target.classList.contains("intersection-target-bottom")) {
              isBottomVisible = entry.isIntersecting;
            } else if (entry.target.classList.contains("intersection-target-top")) {
              isTopVisible = entry.isIntersecting;
            } else {
              isThisVisible = entry.intersectionRatio > 0;
            }
            if (isTopVisible && !isBottomVisible) {
              this._stickyScrollbarStyles.height = "auto";
              this._stickyScrollbarStyles.position = "fixed";
              this._stickyScrollbarStyles["overflow-x"] = "scroll";
            } else if (isThisVisible && !isTopVisible && !isBottomVisible) {
              this._stickyScrollbarStyles.height = "auto";
              this._stickyScrollbarStyles.position = "fixed";
              this._stickyScrollbarStyles["overflow-x"] = "scroll";
            } else if (!isTopVisible && isBottomVisible) {
              this._stickyScrollbarStyles.height = "0";
              this._stickyScrollbarStyles.position = "absolute";
              this._stickyScrollbarStyles["overflow-x"] = "hidden";
            } else {
              this._stickyScrollbarStyles.height = "0";
              this._stickyScrollbarStyles.position = "absolute";
              this._stickyScrollbarStyles["overflow-x"] = "hidden";
            }
          });
          this.requestUpdate();
        },
        { threshold: [0, 1] }
      );
      this.#intersectionObserver.observe(this.shadowRoot.querySelector(".intersection-target-top"));
      this.#intersectionObserver.observe(this.shadowRoot.querySelector(".intersection-target-bottom"));
      this.#intersectionObserver.observe(this);
      this.#resizeObserver = new ResizeObserver(() => {
        this.#calcStickyScrollbarContainerWidth();
      });
      this.#resizeObserver.observe(this);
    }
  }
  updated(changed) {
    if (!changed.has("_scrollTablePadding")) {
      this.#calcScrollTablePadding();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.#intersectionObserver) {
      this.#intersectionObserver.unobserve(this.shadowRoot.querySelector(".intersection-target-top"));
      this.#intersectionObserver.unobserve(this.shadowRoot.querySelector(".intersection-target-bottom"));
      this.#intersectionObserver.unobserve(this);
    }
    if (this.#resizeObserver) {
      this.#resizeObserver.unobserve(this);
    }
  }
  async #calcScrollTablePadding() {
    const [leftTableEl, rightTableEl] = await Promise.all([this._leftTableEl, this._rightTableEl]);
    const elToMeasure = this.stickySide === "left" ? leftTableEl : rightTableEl;
    if (elToMeasure) {
      this._scrollTablePadding = Math.trunc(elToMeasure.getBoundingClientRect().width);
    }
  }
  async #calcStickyScrollbarContainerWidth() {
    if (!this.stickyScrollbar)
      return;
    const [leftTableEl] = await Promise.all([this._leftTableEl, this._rightTableEl]);
    const scrollContainerEl = await this._scrollContainerEl;
    this._stickyScrollbarStyles = {
      ...this._stickyScrollbarStyles,
      width: scrollContainerEl.clientWidth + "px"
    };
    this._stickyScrollBarOverflowWidth = leftTableEl.clientWidth;
  }
  #hideShadow;
  #handleScrollContainerScroll(e) {
    this._shouldShowShadow = true;
    this.#hideShadow();
    if (!this.stickyScrollbar)
      return;
    this.shadowRoot.querySelector(".sticky-scrollbar-container").scrollLeft = e.target.scrollLeft;
  }
  #handleStickyScrollbarScroll(e) {
    this.shadowRoot.querySelector(".scroll-container").scrollLeft = e.target.scrollLeft;
  }
  #wrapWithScrollContainer;
  #defaultTable;
  #leftTable;
  #rightTable;
  get #stickyScrollbarTemplate() {
    return html`
      <div
        class="sticky-scrollbar-container"
        part="sticky-scrollbar"
        style="${styleMap(this._stickyScrollbarStyles)}"
        @scroll=${this.#handleStickyScrollbarScroll}>
        <div class="overflow" style="width: ${this._stickyScrollBarOverflowWidth}px"></div>
      </div>
    `;
  }
  render() {
    if (this.rightColumns.length === 0 || this.leftColumns.length === 0) {
      const table = this.rightColumns.length === 0 ? this.#defaultTable(this.leftColumns) : this.#defaultTable(this.rightColumns);
      return table;
    } else {
      const leftTable = this.stickySide === "right" ? this.#wrapWithScrollContainer(this.#leftTable("scroll-table left")) : this.#leftTable("sticky-table left");
      const rightTable = this.stickySide === "left" ? this.#wrapWithScrollContainer(this.#rightTable("scroll-table right")) : this.#rightTable("sticky-table right");
      return html`
        ${this.stickyScrollbar ? html`<div class="intersection-target-top"></div>` : nothing}
        ${leftTable}
        ${rightTable}
        ${this.stickyScrollbar ? html`
            ${this.#stickyScrollbarTemplate}
            <div class="intersection-target-bottom"></div>` : nothing}
      `;
    }
  }
}
__decorateClass([
  state()
], OmniTableSticky.prototype, "_shouldShowShadow", 2);
__decorateClass([
  state()
], OmniTableSticky.prototype, "_scrollTablePadding", 2);
__decorateClass([
  state()
], OmniTableSticky.prototype, "_stickyScrollbarStyles", 2);
__decorateClass([
  state()
], OmniTableSticky.prototype, "_stickyScrollBarOverflowWidth", 2);
__decorateClass([
  property({ type: String })
], OmniTableSticky.prototype, "stickySide", 2);
__decorateClass([
  property({ type: Array })
], OmniTableSticky.prototype, "leftColumns", 2);
__decorateClass([
  property({ type: Array })
], OmniTableSticky.prototype, "rightColumns", 2);
__decorateClass([
  property({ type: Boolean })
], OmniTableSticky.prototype, "stickyScrollbar", 2);
__decorateClass([
  property({ type: Array })
], OmniTableSticky.prototype, "data", 2);
__decorateClass([
  property({ type: Object })
], OmniTableSticky.prototype, "sort", 2);
__decorateClass([
  property({ type: Number })
], OmniTableSticky.prototype, "nestedIndent", 2);
__decorateClass([
  property({ attribute: false })
], OmniTableSticky.prototype, "keyFn", 2);
__decorateClass([
  property({ type: Boolean })
], OmniTableSticky.prototype, "expandAllOnLoad", 2);
__decorateClass([
  property({ type: Boolean })
], OmniTableSticky.prototype, "hideNestedIndent", 2);
__decorateClass([
  queryAsync("#right-table")
], OmniTableSticky.prototype, "_rightTableEl", 2);
__decorateClass([
  queryAsync("#left-table")
], OmniTableSticky.prototype, "_leftTableEl", 2);
__decorateClass([
  queryAsync(".scroll-container")
], OmniTableSticky.prototype, "_scrollContainerEl", 2);
OmniElement.register("omni-table-sticky", OmniTableSticky);
export {
  OmniTableSticky
};
//# sourceMappingURL=omni-table-sticky.js.map
