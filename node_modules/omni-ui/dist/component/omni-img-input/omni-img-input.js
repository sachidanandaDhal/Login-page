var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
import { html } from "lit";
import { property, query, state } from "lit/decorators.js";
import { classMap } from "lit/directives/class-map.js";
import { ifDefined } from "lit/directives/if-defined.js";
import { styleMap } from "lit/directives/style-map.js";
import { when } from "lit/directives/when.js";
import { OmniElement } from "../../omni-element.js";
import { capitalizeFirstWord, truncateFilename } from "../../omni-util.js";
import "../omni-style/omni-style.js";
import { css } from "lit";
const style = css`:host{display:inline-block}:host([disabled]){--cursor-state: not-allowed;--opacity-state: 0.45}:host([disabled]) .tooltip-container{cursor:not-allowed}form{margin:0;display:flex;align-items:start}form>*+*{margin-left:0.7142857143rem}form .left{display:flex;flex-direction:column;place-content:center;align-items:flex-start;position:relative}slot{display:block}[type=file]{width:0.0714285714rem;height:0.0714285714rem;border:none !important;position:relative;z-index:-1;margin:0 auto !important}.tooltip-container{position:relative}ul,li{padding:0;margin:0}.trigger-container{position:relative;display:flex;flex-direction:column}.tooltip{position:absolute;top:2.6428571429rem;z-index:1;background:#000;color:#fff;min-height:2em;max-height:40em;animation:850ms linear 1 fade-in;background:linear-gradient(to bottom, #2b3952, #142033 100%);border-radius:0.5714285714rem;color:#fff;padding:0.5rem 1.0714285714rem;font-size:0.8571428571rem;font-weight:600;text-align:left;pointer-events:none;overflow-wrap:break-word}#arrow{position:absolute;z-index:1;top:2.4285714286rem;left:2.6785714286rem;width:0.5714285714rem;height:0.5714285714rem;content:"";transform:rotate(45deg);background:linear-gradient(to bottom, #2b3952, #142033 100%)}.has-help [name=help]{display:block;margin-top:8px}div.filenames-container{display:flex;flex-direction:column}div.one-file{display:flex;justify-content:space-between;margin:0 0 0.3571428571rem 0}div.one-file:last-child{margin-bottom:0}div.img-and-name{display:flex}div.img-container{height:2.2857142857rem;width:2.2857142857rem;margin-right:5px}img{object-fit:cover}div#filename{overflow-wrap:anywhere}`;
class OmniImageInputElement extends OmniElement {
  constructor() {
    super(...arguments);
    this.DEFAULT_MAX_SIZE = 1048576;
    this.DEFAULT_ACCEPTED_FILE_TYPES = ["image/jpeg", "image/png", "image/gif", "image/webp"];
    this.FILE_SIZE_TOO_LARGE_MSG = (name) => `${name}'s size is too large`;
    this._files = {};
    this._hasHelp = false;
    this._tooltipErrors = [];
    this.accept = this.DEFAULT_ACCEPTED_FILE_TYPES.join(",");
    this.disabled = false;
    this.maxSize = this.DEFAULT_MAX_SIZE;
    this.multiple = false;
    this.previewSrc = "";
    this.previewable = false;
    this.filename = "";
    this.required = false;
    this.placeholderSrc = "";
  }
  static get styles() {
    return [...super.styles, style];
  }
  async initializeFiles(imgSrc = this.previewSrc) {
    const srcs = Array.isArray(imgSrc) ? imgSrc : [imgSrc];
    const filenames = Array.isArray(this.filename) ? this.filename : [this.filename];
    if (Array.isArray(imgSrc) && !this.multiple) {
      console.error("previewSrc given as array: multiple attribute must be set to true");
    }
    const uniqueFilenames = {};
    const entryPromises = srcs.map(async (src, i) => {
      const response = await fetch(src);
      const blob = await response.blob();
      let filename = filenames[i] ?? src.match(/.*[#/](.*)$/)?.[1] ?? "filename";
      if (uniqueFilenames[filename]) {
        const count = uniqueFilenames[filename];
        uniqueFilenames[filename] += 1;
        filename = `${filename} (${count})`;
      } else {
        uniqueFilenames[filename] = 1;
      }
      const srcSplit = src.split(".");
      const type = `image/${srcSplit[srcSplit.length - 1].replace("jpg", "jpeg")}`;
      const file = new File([blob], filename, { type });
      return [filename, { file, previewSrc: src }];
    });
    this._files = { ...this._files, ...Object.fromEntries(await Promise.all(entryPromises)) };
    if (this._fileInputEl) {
      this._fileInputEl.files = this.#getFileList();
    }
  }
  updated(changedProperties) {
    if (changedProperties.has("previewSrc") && this.previewSrc) {
      this.initializeFiles();
    }
  }
  get validationMessage() {
    return this._fileInputEl?.validationMessage;
  }
  /** reset the selected images */
  reset() {
    if (!this.disabled) {
      this._formEl?.reset();
      if (this._fileInputEl) {
        this._fileInputEl.value = "";
      }
      this._files = {};
    }
  }
  /** check the form input for client-side validation, if false fire invalid event */
  checkValidity() {
    this._fileInputEl?.setCustomValidity("");
    if (this.required && !Object.keys(this._files).length) {
      this._fileInputEl?.setCustomValidity("Please select a file");
      return false;
    }
    if (!Object.keys(this._files).length)
      return true;
    if (!this._fileInputEl?.checkValidity())
      return false;
    return true;
  }
  /**@internal */
  reportValidity() {
    return this._formEl.reportValidity();
  }
  /**@internal */
  async #getInvalidTypeFiles() {
    if (!Object.keys(this._files).length)
      return {};
    const currFiles = Object.values(this._files);
    const invalidFiles = {};
    for (const omniFile of currFiles) {
      const isValidMime = await this.#validMimeType(omniFile.file);
      if (!isValidMime) {
        invalidFiles[omniFile.file.name] = omniFile;
      }
    }
    return invalidFiles;
  }
  /**@internal */
  get #invalidSizeFiles() {
    if (!Object.keys(this._files).length)
      return {};
    return Object.values(this._files).map((one) => {
      return {
        file: one.file,
        isValid: one.file.size < this.maxSize
      };
    }).filter((one) => !one.isValid).reduce((acc, curr) => ({ ...acc, [curr.file.name]: curr }), {});
  }
  /**@internal */
  #onTriggerClick() {
    return this._fileInputEl?.click();
  }
  /**@internal */
  get _tooltipTemplate() {
    return html`
      ${when(this._tooltipErrors.length, () => {
      const paddingL = this._tooltipErrors.length > 1 ? 30 : 20;
      const paddingR = this._tooltipErrors.length > 1 ? 20 : 10;
      const desiredMaxWidth = 300;
      const computedMaxWidth = this.#getMaxTextWidth(this._tooltipErrors) + paddingL + paddingR;
      const maxWidth = computedMaxWidth < desiredMaxWidth ? computedMaxWidth : desiredMaxWidth;
      return html`
          <div id="arrow"></div>
          <ul
            class="tooltip"
            style="${styleMap({
        "list-style-type": this._tooltipErrors.length > 1 ? "disc" : "none",
        width: `${maxWidth}px`,
        padding: `10px ${paddingR}px 10px ${paddingL}px`
      })}">
            ${this._tooltipErrors.map((text) => html`<li>${text}</li>`)}
          </ul>
        `;
    })}
    `;
  }
  /**@internal */
  get #triggerSlotTemplate() {
    const disableStyle = styleMap({ opacity: this.disabled ? 0.5 : 1 });
    return html`
      <div class="tooltip-container">
        <div class="trigger-container">
          <slot name="trigger" part="trigger-slot" @click=${this.#onTriggerClick}>
            <!-- default overridable slot button -->
            <button type="button" class="button is-outlined is-medium" part="trigger" ?disabled=${this.disabled}>
              Browse
            </button>
          </slot>
          ${this.#inputTemplate}
        </div>
        ${this._tooltipTemplate}
      </div>

      <slot name="help" class="is-size-7 has-text-grey" style=${disableStyle}></slot>
    `;
  }
  /**@internal */
  async #onFileChange({ target: { files } }) {
    if (files.length) {
      this._addFilesToOmniFileList(files);
      await this._processInvalidFiles();
      this._createAndEmitChangeEvent();
      this.checkValidity();
    } else {
      this.#setFilesBackAfterCancel();
    }
  }
  /**@internal */
  #getTextWidth(text, context) {
    context.font = getComputedStyle(document.body).font;
    const width = context.measureText(text).width;
    return Math.floor(width);
  }
  /**@internal */
  #getMaxTextWidth(texts) {
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");
    const max = Math.max(...texts.map((text) => this.#getTextWidth(text, context)));
    canvas.remove();
    return max;
  }
  /**@internal */
  _addFilesToOmniFileList(files) {
    for (const file of files) {
      this._files = {
        ...this._files,
        [file.name]: {
          file,
          previewSrc: URL.createObjectURL(file)
        }
      };
    }
  }
  /** remove invalid files from _files, add errors to toolip list, show for 5 sec */
  /**@internal */
  async _processInvalidFiles() {
    const invalidSize = Object.keys(this.#invalidSizeFiles);
    const invalidType = Object.keys(await this.#getInvalidTypeFiles());
    for (const name of invalidSize) {
      delete this._files[name];
      this.#addToolTipErrors(name, "size");
    }
    for (const name of invalidType) {
      delete this._files[name];
      this.#addToolTipErrors(name, "type");
    }
    if (this._fileInputEl) {
      this._fileInputEl.files = this.#getFileList();
    }
    if (this.multiple)
      this._files = { ...this._files };
    else {
      if (Object.keys(this._files).length > 1) {
        const firstFile = Object.keys(this._files)[0];
        delete this._files[firstFile];
      }
      this._files = { ...this._files };
    }
    if (this._tooltipErrors.length) {
      setTimeout(() => {
        this._tooltipErrors = [];
      }, 5e3);
    }
  }
  /**@internal */
  async #validMimeType(file) {
    if (!file)
      return true;
    function check(signature) {
      switch (signature) {
        case "89504e47":
          return "image/png";
        case "47494638":
          return "image/gif";
        case "ffd8ffe0":
        case "ffd8ffe1":
        case "ffd8ffe2":
        case "ffd8ffe3":
        case "ffd8ffe8":
          return "image/jpeg";
        case "52494646":
          return "image/webp";
        default:
          return false;
      }
    }
    const blob = file.slice(0, 4);
    return new Promise((resolve) => {
      const reader = new FileReader();
      reader.onloadend = (e) => {
        const arrayBuffer = e.target.result;
        const hexSignature = new Uint8Array(arrayBuffer).subarray(0, 4);
        let joinedSignature = "";
        for (let i = 0; i < hexSignature.length; i++) {
          joinedSignature += hexSignature[i].toString(16);
        }
        resolve(check(joinedSignature));
      };
      reader.onerror = () => {
        resolve(false);
      };
      reader.readAsArrayBuffer(blob);
    });
  }
  /**@internal */
  #addToolTipErrors(filename, type) {
    const fileTypeError = (name) => {
      const formatter = new Intl.ListFormat("en-US", { style: "long", type: "disjunction" });
      const types = this.accept.split(",");
      const message2 = `${truncateFilename(name)} is not allowed. Only file type ${formatter.format(types)} ${types.length > 1 ? "are" : "is"} allowed`;
      return message2;
    };
    const message = type === "size" ? this.FILE_SIZE_TOO_LARGE_MSG(truncateFilename(filename, 20)) : fileTypeError(filename);
    this._tooltipErrors.push(message);
  }
  /** emits change event if there are one or more files */
  /**@internal */
  _createAndEmitChangeEvent() {
    const fileList = this.#getFileList();
    if (fileList.length) {
      const eventDetail = this.multiple ? { files: [...fileList] } : { file: fileList[0] };
      this.dispatchNewEvent("change", { detail: eventDetail });
    }
  }
  /** set files back on input element on cancel */
  /**@internal */
  #setFilesBackAfterCancel() {
    const fileList = this.#getFileList();
    if (fileList.length) {
      if (this._fileInputEl) {
        this._fileInputEl.files = fileList;
      }
    }
  }
  /**@internal */
  get #inputTemplate() {
    return html`
      <input
        type="file"
        tabindex="-1"
        accept=${ifDefined(this.accept)}
        ?required=${this.required}
        ?multiple=${this.multiple}
        @change=${this.#onFileChange} />
    `;
  }
  /**
   * Remove uploaded file by passing file name
   * @internal
   */
  removeFile(filename, emitEvent = true) {
    const fileList = this.#getFileList(filename);
    if (this._fileInputEl) {
      this._fileInputEl.files = fileList;
    }
    delete this._files[filename];
    this._files = { ...this._files };
    const eventDetail = this.multiple ? { files: [...this.#getFileList()] } : { file: null };
    if (emitEvent) {
      this.dispatchNewEvent("change", { detail: eventDetail });
    }
    this.checkValidity();
  }
  /**@internal */
  #getFileList(excludeFilename = "") {
    const fileBuffer = new DataTransfer();
    for (const omniFile of Object.values(this._files)) {
      if (omniFile.file.name !== excludeFilename) {
        fileBuffer.items.add(omniFile.file);
      }
    }
    return fileBuffer.files;
  }
  /**@internal */
  get #filenameAndPreviewTemplate() {
    const fileNamesContainer = (fileNames) => html`
      <div class="filenames-container" part="filenames-container">${fileNames}</div>
    `;
    const filenames = Object.values(this._files).map(
      (one) => html`
        <div class="one-file">
          <div class="img-and-name">
            <div class="img-container">
              <img src=${one.previewSrc || this.placeholderSrc} part="preview" alt="" />
            </div>
            <div id="filename" part="filename">${truncateFilename(one.file.name, 20)}</div>
          </div>
          <slot name="reset" part="reset" @click=${() => this.removeFile(one.file.name)}>
            <!-- default overridable slot button -->
            <omni-tooltip relateby="label">
              <span slot="invoker">
                <button type="button" class="button is-text is-small is-shadowless" ?disabled=${this.disabled}>
                  <omni-icon class="is-size-2" icon-id="omni:interactive:remove"></omni-icon>
                </button>
              </span>
              <div slot="content">Remove</div>
            </omni-tooltip>
          </slot>
        </div>
      `
    );
    const disableStyle = styleMap({ opacity: this.disabled ? 0.5 : 1 });
    const placeholder = html`
      <slot name="placeholder" part="placeholder" style=${disableStyle}>
        <div>No image selected</div>
      </slot>
    `;
    return Object.keys(this._files).length && this.previewable ? fileNamesContainer(filenames) : placeholder;
  }
  /**@internal */
  get #formTemplate() {
    return html`
      <fieldset ?disabled=${this.disabled}>
        <form part="form">
          <div class="left">${this.#triggerSlotTemplate}</div>
          ${this.#filenameAndPreviewTemplate}
        </form>
      </fieldset>
    `;
  }
  /**@internal */
  #onSlotChange({ target }) {
    ["help"].forEach((name) => {
      if (target.matches(`[name=${name}]`)) {
        this[`_has${capitalizeFirstWord(name)}`] = target.assignedElements().length > 0;
      }
    });
  }
  render() {
    return html`
      <omni-style class=${classMap({ "has-help": this._hasHelp })} @slotchange=${this.#onSlotChange}>
        ${this.#formTemplate}
      </omni-style>
    `;
  }
}
__decorateClass([
  state()
], OmniImageInputElement.prototype, "_files", 2);
__decorateClass([
  state()
], OmniImageInputElement.prototype, "_hasHelp", 2);
__decorateClass([
  state()
], OmniImageInputElement.prototype, "_tooltipErrors", 2);
__decorateClass([
  property({ type: String })
], OmniImageInputElement.prototype, "accept", 2);
__decorateClass([
  property({ type: Boolean, reflect: true })
], OmniImageInputElement.prototype, "disabled", 2);
__decorateClass([
  property({ type: Number })
], OmniImageInputElement.prototype, "maxSize", 2);
__decorateClass([
  property({ type: Boolean, reflect: true })
], OmniImageInputElement.prototype, "multiple", 2);
__decorateClass([
  property({ type: String })
], OmniImageInputElement.prototype, "previewSrc", 2);
__decorateClass([
  property({ type: Boolean, reflect: true })
], OmniImageInputElement.prototype, "previewable", 2);
__decorateClass([
  property({ type: String })
], OmniImageInputElement.prototype, "filename", 2);
__decorateClass([
  property({ type: Boolean, reflect: true })
], OmniImageInputElement.prototype, "required", 2);
__decorateClass([
  property()
], OmniImageInputElement.prototype, "placeholderSrc", 2);
__decorateClass([
  query("[type=file]")
], OmniImageInputElement.prototype, "_fileInputEl", 2);
__decorateClass([
  query("form")
], OmniImageInputElement.prototype, "_formEl", 2);
OmniElement.register("omni-img-input", OmniImageInputElement);
export {
  OmniImageInputElement
};
//# sourceMappingURL=omni-img-input.js.map
