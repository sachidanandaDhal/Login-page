var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
import { html, nothing } from "lit";
import { property, query, state } from "lit/decorators.js";
import { styleMap } from "lit/directives/style-map.js";
import { classMap } from "lit/directives/class-map.js";
import { OmniElement } from "../../omni-element.js";
import { ClickOutsideController } from "../../controllers/click-outside-controller.js";
import { getElementSize } from "../../omni-util.js";
import { ElementInternalsBase } from "../../element-internals-base.js";
import { isGroupHeader } from "./omni-dropdown.types.js";
import "../omni-pill-list/omni-pill-list.js";
import "../omni-loading-indicator/omni-loading-indicator.js";
import "../omni-icon/omni-icon.js";
import "../omni-tooltip/omni-tooltip.js";
import "../omni-search/omni-search.js";
import "../omni-options/omni-options.js";
import "../omni-checkbox/omni-checkbox.js";
import { css } from "lit";
const styles = css`:host{width:21.4285714286rem;--cursor-state: pointer}:host([disabled]){opacity:.45;--cursor-state: not-allowed;cursor:not-allowed}:host(:not([disabled]):hover){--cursor-state: pointer}:host(:focus-visible){outline:none}:host(:focus-visible) .target{border:.0714285714rem solid var(--color-primary)}.container{position:relative;display:flex;flex-direction:column}.container .wrapper{display:flex;justify-content:flex-start;align-items:center}p.single-select{text-overflow:ellipsis;overflow:hidden;white-space:nowrap;padding-right:.5714285714rem;font-size:1rem}p.single-select.label-variant{font-weight:600}.label-container{display:flex;justify-content:flex-start;align-items:center;height:.9285714286rem}.label-container.top{margin-bottom:.6428571429rem;margin-left:.5rem}.label-container.left{margin-right:.7142857143rem}.label-container label{line-height:.9285714286rem;white-space:nowrap;color:var(--color-core-dark);font-size:.7857142857rem;opacity:.6}.label-container omni-tooltip{padding:0 0 .4285714286rem .4285714286rem}.label-container omni-tooltip omni-icon{--color-icon-lines: var(--color-core-dark)}.target{background-color:var(--color-pale-grey-two);height:2.5714285714rem;display:flex;align-items:center;justify-content:space-between;cursor:var(--cursor-state);user-select:none;border-radius:.2857142857rem;border:.0714285714rem solid rgba(0,0,0,0);padding:0 1.3571428571rem 0 1.3571428571rem}.target.label-variant{height:1.8571428571rem;background-color:rgba(0,0,0,0);padding:.3571428571rem .8571428571rem}.target.label-variant:hover{background-color:#f5f8fb}.target.label-variant:focus,.target.label-variant.opened{background-color:#fff;border:.0714285714rem solid var(--color-primary)}.target.left{flex-grow:1}.target.opened{background-color:#fff}.target.opened p{color:var(--color-core-dark)}.target.opened:not(.label-variant){border:.0714285714rem solid var(--color-primary)}.target.filled p{color:var(--color-core-dark)}.target.has-error{border:.0714285714rem solid var(--color-error)}.target.typeahead{padding-left:0;padding-right:0}.target .target-icons{display:flex;justify-content:flex-end;align-items:center}.target .target-icons .x-close{margin-left:3.2857142857rem}.target omni-icon{min-width:1.2857142857rem;min-height:1.2857142857rem}.target omni-pill-list{flex:0 0 calc(100% - 2rem);max-width:calc(100% - 2rem)}.target omni-search{flex:0 0 100%;height:100%;height:2.5714285714rem;border:none}.target omni-search::part(search-icon-opened-wrapper){margin-left:.8571428571rem}.target omni-search::part(search-icon-opened){--color-icon-lines: var(--color-shark);--size-1: 1rem}.target omni-search::part(input){font-size:.8571428571rem;background-color:rgba(0,0,0,0);border:none;box-shadow:none;padding-left:3.0714285714rem}.target omni-search::part(input)::placeholder{font-size:.8571428571rem}.target p{color:var(--color-core-medium);margin:0}.target p.label-variant{color:var(--color-core-dark);font-weight:600}.target .enable-tooltip::part(hint){pointer-events:auto;cursor:default}.dropdown{background-color:#fff;position:absolute;z-index:6;top:2.8571428571rem;width:100%;left:0;max-height:15.1428571429rem;padding:0;border-radius:.7142857143rem;box-shadow:0 .5714285714rem 3.1428571429rem -.3571428571rem rgba(38,55,79,.29);overflow:auto;cursor:pointer}.dropdown.top{top:4.4285714286rem}.dropdown.no-label{top:2.8571428571rem}.dropdown.label-variant{top:2.1428571429rem}.dropdown.cursor-default{cursor:default}.dropdown .no-results,.dropdown .add-dynamic{margin:0 0 0 2.2857142857rem}.dropdown .add-dynamic{cursor:pointer}.dropdown.extend-right{width:calc(100% + 3.1428571429rem)}.dropdown.padding{padding:.5714285714rem 0}.dropdown omni-tooltip{display:flex;flex-direction:column}.dropdown .select-all-button{display:flex;justify-content:flex-end;align-items:center;padding:.4285714286rem 1.2857142857rem}.dropdown .select-all-button a{color:#00a1d2}.dropdown .select-all-button p{color:rgba(59,62,63,.5019607843);margin:0;font-size:.8571428571rem;line-height:.8571428571rem;letter-spacing:.0023rem}.dropdown omni-search{height:2.5714285714rem;border:.0714285714rem solid rgba(0,0,0,0);border-bottom:.0714285714rem solid #edf0f5;padding-bottom:.1428571429rem;box-sizing:content-box}.dropdown omni-search::part(search-icon-opened){--color-icon-lines: var(--color-shark);--size-1: 1rem}.dropdown omni-search::part(input){background-color:rgba(0,0,0,0);border:none;box-shadow:none;border:.0714285714rem solid rgba(0,0,0,0);font-size:.8571428571rem}.dropdown omni-search::part(input):focus{border:.0714285714rem solid var(--color-primary)}.dropdown omni-search::part(input)::placeholder{font-size:.8571428571rem}.dropdown omni-loading-indicator{padding-top:.5714285714rem;min-height:2.5714285714rem}.dropdown omni-loading-indicator::part(svg){width:2rem}.dropdown .item{min-height:2.5714285714rem;padding:.5714285714rem .5714285714rem .5714285714rem 0;margin:0;user-select:none;display:flex;flex-grow:1;align-items:flex-start;justify-content:flex-start;border:.0714285714rem solid rgba(0,0,0,0)}.dropdown .item:focus,.dropdown .item:active,.dropdown .item.selected,.dropdown .item:hover{background-color:var(--white);outline:none}.dropdown .item omni-checkbox{margin-top:calc(1rem - 0.7857142857rem)}.dropdown .item:not(.disabled):hover omni-checkbox{--checkbox-border-color: var(--color-primary)}.dropdown .item label{color:#3b3e3f;pointer-events:none}.dropdown .item .item-gutter{display:flex;justify-content:center;align-items:center;min-width:2.2857142857rem;margin-top:.1428rem}.dropdown .item .item-gutter.groupheader{min-width:1.1428571429rem}.dropdown .item .item-gutter omni-icon{--color-icon-lines: var(--color-primary);height:1.1428571429rem;width:1.1428571429rem}.dropdown .item.disabled{cursor:not-allowed}.dropdown .item.disabled:hover{background-color:rgba(0,0,0,0)}.dropdown .item.disabled:focus,.dropdown .item.disabled:active{outline:none;border:.0714285714rem solid rgba(0,0,0,0);background-color:rgba(0,0,0,0)}.dropdown .item.disabled label{color:#a2a9ad !important}.dropdown .item.groupheader span{color:#a2a9ad !important;font-weight:600}.footer-spacer{height:1.8571428571rem;min-height:1.8571428571rem;max-height:1.8571428571rem;flex:0 0 100%}.footer-container{display:flex;flex:0 0 100%;padding:.5714285714rem 0 0 .7142857143rem}.footer-container.help-text{justify-content:flex-end;align-items:center}.footer-container.error-text{justify-content:flex-start;align-items:center}.footer-container omni-icon{margin-right:.5714285714rem;--color-icon-lines: var(--color-error)}.footer-container span{font-size:.8571428571rem;font-weight:400;color:var(--color-almost-black)}`;
const _OmniDropdown = class _OmniDropdown extends ElementInternalsBase {
  constructor() {
    super(...arguments);
    this.#clickOutsideController = new ClickOutsideController(this, () => {
      this.opened = false;
      this._searchTerm = "";
    });
    this._selected = /* @__PURE__ */ new Set();
    this._disabled = /* @__PURE__ */ new Set();
    this._disabledOnMaxSet = /* @__PURE__ */ new Set();
    this._searchTerm = "";
    this._filteredOptions = [];
    this._isLoading = false;
    this._hasGroupHeaders = false;
    this.opened = false;
    this.disableonmax = false;
    this.multiselect = false;
    this.noselect = false;
    this.selectall = false;
    this.typeahead = false;
    this.searchindropdown = false;
    this.dynamicadditions = false;
    this.hidefooter = false;
    this.valueMissingMessage = "Please select an option";
    this.label = "";
    this.labelTooltip = "";
    this.placeholder = "Select an option";
    this.searchPlaceholder = "Search";
    this.helpText = "";
    this.error = "";
    this.disabledMessage = "";
    this.labelPosition = "top";
    this.dropdownAlignment = "vertical";
    this.inputDebounceTimer = 0;
    this.variant = "default";
    this.showxicon = false;
    this.options = [];
    this.value = [];
    this.#handleKeysOnDropdown = (e) => {
      this.updateComplete.then(() => {
        if (e.key === "Enter" && !this.opened) {
          this.#handleTargetClicked(e);
        }
        if (e.key === "Escape") {
          this.#handleTargetClicked(e, true);
        }
      });
    };
  }
  static get styles() {
    return [...super.styles, styles];
  }
  /** given an option, find first group header with higher index than option */
  static findGroupHeaderForItem(option, allOptions) {
    const index = allOptions.indexOf(option);
    const reversedOptions = [...allOptions].reverse();
    for (const option2 of reversedOptions.slice(reversedOptions.length - index)) {
      if (typeof option2 === "object" && option2.groupheader) {
        return option2;
      }
    }
    return null;
  }
  #clickOutsideController;
  async connectedCallback() {
    super.connectedCallback();
    this.addEventListener("keyup", this.#handleKeysOnDropdown);
    this.tabIndex = 0;
    this._internals.setFormValue("");
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener("keyup", this.#handleKeysOnDropdown);
  }
  async willUpdate(changed) {
    if (changed.has("options")) {
      this.options.forEach((option) => {
        if (option && typeof option === "object" && option.disabled) {
          this._disabled.add(option);
        }
        if (option && isGroupHeader(option)) {
          this._disabled.add(option);
        }
      });
      this._hasGroupHeaders = this.options?.some((option) => isGroupHeader(option));
      this._isLoading = true;
      this._filteredOptions = await this.#getFilteredOptions();
      this._isLoading = false;
    }
    if ((changed.has("min") || changed.has("max")) && !this.multiselect) {
      console.warn(`${this.localName}: setting min or max is only allowed when multiselect = true`);
    }
    if (changed.has("value") || changed.has("min") || changed.has("max")) {
      if (changed.get("value")?.toString() !== this.value?.toString()) {
        this._selected.clear();
        const add = [];
        for (const option of this.value) {
          if (!this._selected.has(option)) {
            add.push(option);
          }
        }
        this.#commitSelections(add, false, true);
      }
    }
    if (changed.has("variant") && this.variant === "label") {
      this.dropdownAlignment = "extend-right";
      this.helpText = "";
      this.label = "";
      this.labelTooltip = "";
      this.multiselect = false;
      this.error = "";
      this.labelPosition = "top";
      this.hidefooter = true;
      this.typeahead = false;
      this.searchindropdown = false;
      this.selectall = false;
    }
    if (changed.has("fetchOptionsFn")) {
      if (this.options?.length) {
        console.warn("<omni-dropdown>: options should not be set by property when providing a fetchOptionsFn");
      }
    }
    if (changed.has("_searchTerm")) {
      this._isLoading = true;
      this.#getFilteredOptions().then((options) => {
        this._filteredOptions = options;
        this._isLoading = false;
      });
    }
    if (changed.has("_selected") && this.disableonmax) {
      this.#disableOnMaxLimit();
    }
  }
  #disableOnMaxLimit() {
    if (this.max && this._selected.size >= this.max) {
      this.options.forEach((option) => {
        if (!this._selected.has(option)) {
          this._disabledOnMaxSet.add(option);
        }
      });
    } else {
      this._disabledOnMaxSet = /* @__PURE__ */ new Set();
    }
  }
  async firstUpdated() {
    await this.updateComplete;
    if (this.required && !this._selected.size) {
      this._internals.setValidity({ valueMissing: true }, this.valueMissingMessage, this.targetEl);
    }
    this._computedTargetWidth = this.targetEl.clientWidth;
    this._computedLabelWidth = this.labelEl ? getElementSize(this.labelEl).width : null;
    this._isLoading = true;
    this.#getFilteredOptions().then((options) => {
      this._isLoading = false;
      this._filteredOptions = options;
    });
  }
  updated(changed) {
    if (!changed.has("_computedTargetWidth")) {
      this._computedTargetWidth = this.targetEl.clientWidth;
    }
    if (!changed.has("_computedLabelWidth")) {
      this._computedLabelWidth = this.labelEl ? getElementSize(this.labelEl).width : null;
    }
  }
  async #getFilteredOptions() {
    if (this.fetchOptionsFn) {
      return this.fetchOptionsFn(this._searchTerm);
    }
    const groupHeadersExist = this.options.some(
      (option) => typeof option === "object" && option.groupheader
    );
    const foundInSearch = [];
    for (const option of this.options) {
      if (!this.typeahead) {
        foundInSearch.push({ match: true, option });
      } else if (typeof option === "object" && option.groupheader) {
        foundInSearch.push({ match: false, option });
      } else {
        const val = String(this.#toDisplayValue(option));
        const match = val.toLowerCase().trim().includes(this._searchTerm.trim().toLowerCase());
        foundInSearch.push({ match, option });
      }
    }
    if (groupHeadersExist && this.typeahead) {
      const groupHeaders = /* @__PURE__ */ new Set();
      for (const result of foundInSearch) {
        if (!isGroupHeader(result.option) && result.match) {
          const header = _OmniDropdown.findGroupHeaderForItem(result.option, this.options);
          if (header) {
            groupHeaders.add(header);
          }
        }
      }
      foundInSearch.forEach((result) => {
        if (groupHeaders.has(result.option)) {
          result.match = true;
        }
      });
    }
    return foundInSearch.filter((result) => result.match).map((result) => result.option);
  }
  #handleKeysOnDropdown;
  #toDisplayValue(option) {
    return option && typeof option === "object" ? option.value : option;
  }
  #handleRemoveItem(e) {
    e.stopPropagation();
    if (!this.disabled) {
      this.#handleSelectChange(e);
    }
  }
  #emitChange() {
    const [firstSelected] = [...this._selected.values()];
    const allSelected = [...this._selected.values()];
    const eventDetail = {
      detail: this.multiselect ? allSelected : firstSelected ? firstSelected : null
    };
    this.dispatchNewEvent("change", eventDetail);
  }
  get #selectedToFormDataString() {
    return [...this._selected.values()].map((one) => {
      if (one && typeof one === "object") {
        return String(one.value);
      }
      return String(one);
    }).join(",");
  }
  get #labelTemplate() {
    if (!this.label)
      return nothing;
    const tooltipLabel = html`
      <div class="label-container ${this.labelPosition}">
        <label part="label">${this.label}</label>
        ${this.labelTooltip ? html`
              <omni-tooltip>
                <omni-icon slot="invoker" icon-id="icon:informative:info"></omni-icon>
                <span slot="content">${this.labelTooltip}</span>
              </omni-tooltip>
            ` : nothing}
      </div>
    `;
    return tooltipLabel;
  }
  /** toggles opened property and emits event */
  #handleTargetClicked(e, opened = this.opened) {
    this.opened = this.disabled ? false : !opened;
    if (this.typeahead && !this.searchindropdown && !this.opened) {
      this.opened = true;
    }
    this.dispatchNewEvent("dropdown", { detail: this.opened });
  }
  #handleSearchChange({ detail: { value } }) {
    this._searchTerm = value;
  }
  get #searchInputTemplate() {
    return html`
      <omni-search
        .inputDebounceTimer=${this.inputDebounceTimer}
        .value=${this._searchTerm}
        .ph="${this.searchPlaceholder}"
        isopen
        @search-update=${this.#handleSearchChange}>
      </omni-search>
    `;
  }
  // TODO decide what the 'clear' event does. does it clear the current selection and emit an event?
  #handleVariantClear(e) {
    e.stopPropagation();
    this.reset();
    this.dispatchNewEvent("clear");
  }
  get #innerTargetTemplateForType() {
    const targetTypes = {
      placeholder: () => {
        const sliceAt = 30;
        const placeholderToDisplay = this.placeholder.slice(0, sliceAt) + (this.placeholder.length > sliceAt ? "..." : "");
        return html`<p class="${this.variant === "label" ? "single-select label-variant" : ""}">
          ${placeholderToDisplay}
        </p>`;
      },
      one: () => {
        const selected = [...this._selected.values()][0];
        return html`<p class="single-select ${this.variant === "label" ? "label-variant" : ""}">
          ${this.#toDisplayValue(selected)}
        </p>`;
      },
      multi: () => {
        if (!this._computedTargetWidth)
          return nothing;
        const selectedForPillList = [...this._selected.values()];
        const innerWidths = 20 + 18 + 26 + 30;
        return html`<omni-pill-list
          class="${this.disabled ? "enable-tooltip" : ""}"
          .items=${selectedForPillList}
          .overflowWidth=${this._computedTargetWidth - innerWidths}
          @remove=${this.#handleRemoveItem}>
        </omni-pill-list>`;
      },
      typeahead: () => this.#searchInputTemplate
    };
    if (this.multiselect && this._hasGroupHeaders) {
      return targetTypes.placeholder();
    }
    if (this.typeahead && !this.searchindropdown) {
      return targetTypes.typeahead();
    }
    if (this.placeholder && !this._selected.size) {
      return targetTypes.placeholder();
    }
    if (this._selected.size === 1 && !this.multiselect) {
      return targetTypes.one();
    }
    return targetTypes.multi();
  }
  get #targetTemplate() {
    const classes = classMap({
      target: true,
      opened: this.opened,
      filled: this._selected.size > 0,
      "has-error": this.error ? true : false,
      // TODO: make this work with internals
      typeahead: this.typeahead && !this.searchindropdown,
      [this.labelPosition]: true,
      "label-variant": this.variant === "label"
    });
    return html`
      <div class="${classes}" part="target ${this.opened ? "opened" : ""}" @click=${this.#handleTargetClicked}>
        ${this.#innerTargetTemplateForType}
        <div class="target-icons">
          ${!this.typeahead || this.searchindropdown ? html`<omni-icon icon-id="omni:interactive:${this.opened ? "up" : "down"}"> </omni-icon>` : nothing}
          ${this.variant === "label" && this._selected.size && this.showxicon ? html`<omni-icon
                class="x-close is-size-6"
                icon-id="icon:interactive:remove"
                @click=${this.#handleVariantClear}></omni-icon>` : nothing}
        </div>
      </div>
    `;
  }
  #handleEnterOnItem(e) {
    if (e.detail.eventKey === "Enter") {
      this.#commitSelections([e.detail.value]);
    }
  }
  #handleDynamicAddition() {
    this.options.push(this._searchTerm);
    this.select([this._searchTerm]);
    this.#handleTargetClicked(null);
    this._searchTerm = "";
  }
  #handleSelectChange({ detail: activeOption }) {
    this.#commitSelections([activeOption]);
  }
  get #dropdownTemplate() {
    if (!this.opened)
      return nothing;
    const classes = classMap({
      dropdown: true,
      "no-label": !this.label,
      top: this.labelPosition === "top",
      left: this.labelPosition === "left",
      [this.dropdownAlignment]: true,
      "label-variant": this.variant === "label",
      "cursor-default": this._isLoading || !this._filteredOptions?.length,
      padding: this._filteredOptions?.length || this._searchTerm || this._isLoading || this.searchindropdown
    });
    const inlineStyles = styleMap(
      this.labelPosition === "left" ? {
        ...this._computedLabelWidth ? { left: `${this._computedLabelWidth}px` } : {},
        ...this._computedTargetWidth ? { width: `${this._computedTargetWidth}px` } : {}
      } : {}
    );
    return html`
      <div part="dropdown" class="${classes}" style=${inlineStyles}>
        ${this.selectall && this.multiselect ? html`<div class="select-all-button">
              <p>Select : <a @click=${() => this.select(this.options)}>All</a> | <a @click=${this.reset}>None</a></p>
            </div>` : nothing}
        ${this.searchindropdown ? this.#searchInputTemplate : nothing}
        ${this._isLoading ? html`<omni-loading-indicator></omni-loading-indicator>` : nothing}
        ${this._filteredOptions?.length && !this._isLoading ? html` <omni-options
              ?hasgroupheaders=${this.options.some((one) => one.groupheader)}
              .options=${this._filteredOptions}
              .multiselect=${this.multiselect}
              .disabledList=${/* @__PURE__ */ new Set([...this._disabled, ...this._disabledOnMaxSet])}
              .disabledMessage=${this.disabledMessage}
              .selected=${this._selected}
              @selectChange=${this.#handleSelectChange}
              @enterOnItem=${this.#handleEnterOnItem}></omni-options>` : nothing}
        ${!this._filteredOptions?.length && !this._isLoading && this.dynamicadditions && this._searchTerm ? html`<div class="item">
              <p class="add-dynamic" @click=${this.#handleDynamicAddition}>add ${this._searchTerm} as option</p>
            </div>` : nothing}
        ${!this._filteredOptions?.length && !this._isLoading && !this.dynamicadditions && this._searchTerm ? html`<div class="item disabled">
              <p class="no-results">No results</p>
            </div>` : nothing}
      </div>
    `;
  }
  get #footerTemplate() {
    if (this.hidefooter)
      return nothing;
    const footerSpacer = html`<div class="footer-spacer"></div>`;
    if (!this.error && !this.helpText)
      return footerSpacer;
    if (this.error) {
      return html` <div class="footer-container error-text">
        <omni-icon icon-id="omni:informative:error"></omni-icon>
        <span>${this.error}</span>
      </div>`;
    }
    if (this.helpText) {
      return html`
        <div class="footer-container help-text">
          <span>${this.helpText}</span>
        </div>
      `;
    }
  }
  /**
   * - logic for selecting single, multi, noselct, and disabled options.
   * - handles form value and validity
   * - TODO: refactor for simplicity and handle revalidating on min/max changes after init */
  #commitSelections(options, shouldSelect = null, skipEmit = false) {
    if (!options.length)
      return;
    for (const option of options) {
      if (this._disabled.has(option))
        continue;
      const existsInSelected = shouldSelect ?? this._selected.has(option);
      this._internals.setValidity({});
      const logicHandler = {
        singleselect: () => {
          this._selected.clear();
          if (!existsInSelected) {
            this._selected.add(option);
            this._internals.setFormValue(this.#selectedToFormDataString);
          } else {
            this._internals.setFormValue("");
            if (this.required) {
              this._internals.setValidity({ valueMissing: true }, this.valueMissingMessage, this.targetEl);
            }
          }
          this.opened = false;
        },
        multiselect: () => {
          if (!existsInSelected) {
            this._selected.add(option);
            this._internals.setFormValue(this.#selectedToFormDataString);
          } else {
            this._selected.delete(option);
            this._internals.setFormValue(this.#selectedToFormDataString);
          }
          if (this.required && this._selected.size < 1 && !this.min && !this.max) {
            this._internals.setValidity({ valueMissing: true }, this.valueMissingMessage, this.targetEl);
          }
          if (this.min && !this.max && this._selected.size < this.min) {
            this._internals.setValidity(
              { rangeUnderflow: true },
              `Must make at least ${this.min} selections.`,
              this.targetEl
            );
          }
          if (!this.min && this.max && this._selected.size > this.max) {
            this._internals.setValidity(
              { rangeOverflow: true },
              `Only ${this.max} maximum selections allowed.`,
              this.targetEl
            );
          }
          if (this.min && this.max && (this._selected.size < this.min || this._selected.size > this.max)) {
            this._internals.setValidity(
              { customError: true },
              `Must make at least ${this.min} minimum and ${this.max} maximum selections.`,
              this.targetEl
            );
          }
        }
      };
      logicHandler[this.multiselect ? "multiselect" : "singleselect"]();
    }
    if (this.valid) {
      this.error = "";
    }
    this._selected = new Set(this._selected);
    this.#updateReflectedValue();
    if (!skipEmit) {
      this.#emitChange();
    }
    if (this.noselect) {
      this._selected = /* @__PURE__ */ new Set();
      this.#updateReflectedValue();
    }
  }
  #updateReflectedValue() {
    this.value = [...this._selected.values()];
  }
  /** select items in dropdown */
  select(options) {
    this.#commitSelections(options, false);
  }
  /** unselect items in dropdown */
  unselect(options) {
    this.#commitSelections(options, true);
  }
  /** toggle items to be selected or unselected based on current state */
  toggle(options) {
    this.#commitSelections(options);
  }
  /** add options to the list of disabled options */
  disableOptions(options) {
    options.forEach((option) => {
      this._disabled.add(option);
    });
  }
  /** reset all selected options, form value, and reflected value */
  reset() {
    this._selected = /* @__PURE__ */ new Set();
    this._disabled = /* @__PURE__ */ new Set();
    this.options.forEach((option) => {
      if (option && typeof option === "object" && option.disabled) {
        this._disabled.add(option);
      }
    });
    this.#updateReflectedValue();
    if (this.required) {
      this._internals.setValidity({ valueMissing: true }, this.valueMissingMessage, this.targetEl);
    } else {
      this._internals.setValidity({});
    }
    this._internals.setFormValue("");
    this.#emitChange();
  }
  /** @internal */
  #conditionalLeftLabelWrapper(template) {
    if (this.labelPosition === "left") {
      return html` <div class="wrapper">${template}</div> `;
    } else {
      return template;
    }
  }
  //prettier-ignore
  render() {
    return html`
      <div class="container ${this.labelPosition}">
        ${this.#conditionalLeftLabelWrapper(html` 
          ${this.#labelTemplate} 
          ${this.#targetTemplate} 
        `)}
        ${this.#footerTemplate} 
        ${this.#dropdownTemplate}
      </div>
    `;
  }
};
__decorateClass([
  state()
], _OmniDropdown.prototype, "_selected", 2);
__decorateClass([
  state()
], _OmniDropdown.prototype, "_disabled", 2);
__decorateClass([
  state()
], _OmniDropdown.prototype, "_disabledOnMaxSet", 2);
__decorateClass([
  state()
], _OmniDropdown.prototype, "_computedTargetWidth", 2);
__decorateClass([
  state()
], _OmniDropdown.prototype, "_computedLabelWidth", 2);
__decorateClass([
  state()
], _OmniDropdown.prototype, "_searchTerm", 2);
__decorateClass([
  state()
], _OmniDropdown.prototype, "_filteredOptions", 2);
__decorateClass([
  state()
], _OmniDropdown.prototype, "_isLoading", 2);
__decorateClass([
  state()
], _OmniDropdown.prototype, "_hasGroupHeaders", 2);
__decorateClass([
  property({ type: Boolean, attribute: true, reflect: true })
], _OmniDropdown.prototype, "opened", 2);
__decorateClass([
  property({ type: Boolean, attribute: true, reflect: true })
], _OmniDropdown.prototype, "disableonmax", 2);
__decorateClass([
  property({ type: Boolean, attribute: true, reflect: true })
], _OmniDropdown.prototype, "multiselect", 2);
__decorateClass([
  property({ type: Boolean, attribute: true, reflect: true })
], _OmniDropdown.prototype, "noselect", 2);
__decorateClass([
  property({ type: Boolean, attribute: true, reflect: true })
], _OmniDropdown.prototype, "selectall", 2);
__decorateClass([
  property({ type: Boolean, attribute: true, reflect: true })
], _OmniDropdown.prototype, "typeahead", 2);
__decorateClass([
  property({ type: Boolean, attribute: true, reflect: true })
], _OmniDropdown.prototype, "searchindropdown", 2);
__decorateClass([
  property({ type: Boolean, attribute: true, reflect: true })
], _OmniDropdown.prototype, "dynamicadditions", 2);
__decorateClass([
  property({ type: Boolean, attribute: true, reflect: true })
], _OmniDropdown.prototype, "hidefooter", 2);
__decorateClass([
  property({ type: String })
], _OmniDropdown.prototype, "name", 2);
__decorateClass([
  property({ type: String })
], _OmniDropdown.prototype, "valueMissingMessage", 2);
__decorateClass([
  property({ type: String })
], _OmniDropdown.prototype, "label", 2);
__decorateClass([
  property({ type: String })
], _OmniDropdown.prototype, "labelTooltip", 2);
__decorateClass([
  property({ type: String })
], _OmniDropdown.prototype, "placeholder", 2);
__decorateClass([
  property({ type: String })
], _OmniDropdown.prototype, "searchPlaceholder", 2);
__decorateClass([
  property({ type: String })
], _OmniDropdown.prototype, "helpText", 2);
__decorateClass([
  property({ type: String })
], _OmniDropdown.prototype, "error", 2);
__decorateClass([
  property({ type: String })
], _OmniDropdown.prototype, "disabledMessage", 2);
__decorateClass([
  property({ type: String })
], _OmniDropdown.prototype, "labelPosition", 2);
__decorateClass([
  property({ type: String })
], _OmniDropdown.prototype, "dropdownAlignment", 2);
__decorateClass([
  property({ type: Number })
], _OmniDropdown.prototype, "min", 2);
__decorateClass([
  property({ type: Number })
], _OmniDropdown.prototype, "max", 2);
__decorateClass([
  property({ type: Number })
], _OmniDropdown.prototype, "inputDebounceTimer", 2);
__decorateClass([
  property({ type: String })
], _OmniDropdown.prototype, "variant", 2);
__decorateClass([
  property({ type: Boolean, attribute: true, reflect: true })
], _OmniDropdown.prototype, "showxicon", 2);
__decorateClass([
  property({ attribute: false })
], _OmniDropdown.prototype, "options", 2);
__decorateClass([
  property({ attribute: false })
], _OmniDropdown.prototype, "value", 2);
__decorateClass([
  property({ attribute: false })
], _OmniDropdown.prototype, "fetchOptionsFn", 2);
__decorateClass([
  query(".target")
], _OmniDropdown.prototype, "targetEl", 2);
__decorateClass([
  query(".label-container")
], _OmniDropdown.prototype, "labelEl", 2);
let OmniDropdown = _OmniDropdown;
OmniElement.register("omni-dropdown", OmniDropdown);
export {
  OmniDropdown
};
//# sourceMappingURL=omni-dropdown.js.map
