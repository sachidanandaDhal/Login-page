var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
import { html, nothing } from "lit";
import { property, state } from "lit/decorators.js";
import { classMap } from "lit/directives/class-map.js";
import { ifDefined } from "lit/directives/if-defined.js";
import { repeat } from "lit/directives/repeat.js";
import { OmniElement } from "../../omni-element.js";
import { css } from "lit";
const styles = css`:host{--cell-bg-editable: var(--color-pale-grey-two);--text-color-editable: #3b3e3f;--table-row-background-color: var(--color-white);--table-row-highlight-color: rgba(254, 216, 130, 0.35);--cell-expand-collapse-max-width: 24ch}.table-container{width:100%;height:100%}th.is-sortable{cursor:pointer}th>span{transition:color .25s ease}th.is-sortable:hover>span,th.is-sorted>span{color:var(--color-electric-blue)}th{position:relative}th>omni-icon{transition:fill .25s ease;position:absolute;margin:3px}th.is-sortable:hover>omni-icon,th.is-sorted>omni-icon{fill:var(--color-electric-blue)}th>*,td>*{vertical-align:middle}tr:hover .is-editable,tr:hover .input.is-static.is-editable{color:var(--text-color-editable);background-color:var(--cell-bg-editable)}tr.header,tr.header:hover{background-color:rgba(0,0,0,0) !important}tr,tr:hover{background-color:var(--table-row-background-color) !important}tr.highlight{background-color:var(--table-row-highlight-color) !important}tr.is-hovered{transform:none !important}td.is-main{font-weight:600;color:var(--color-almost-black);transition:color .25s ease}td.is-main:hover{color:var(--color-electric-blue);cursor:pointer}.omni th.is-clamped,.omni td.is-clamped{max-width:24ch;display:table-cell}.omni th.is-clamped>*,.omni td.is-clamped>*{display:inline-block;max-width:100%;overflow:hidden;text-overflow:ellipsis}td{background-color:rgba(0,0,0,0) !important}td:hover{background-color:rgba(0,0,0,0) !important}td.expand,td.expand:hover{width:60px;background-color:rgba(0,0,0,0) !important;padding:0 !important;position:relative}.expand .expand-wrapper{padding:.6rem;height:100%;display:flex;align-items:center;justify-content:flex-start}.expand-wrapper button.is-text.is-stateless{border:none}.expand-wrapper.is-clamped{max-width:calc(var(--cell-expand-collapse-max-width) + 56px)}.expand-wrapper.is-clamped span.expand-content{display:inline-block;max-width:var(--cell-expand-collapse-max-width);overflow:hidden;text-overflow:ellipsis}.expand-spacer{width:41px;min-width:41px}.leftbar{position:absolute;left:0;top:50%;transform:translateY(-50%);height:30px;width:3px;border-top-right-radius:5px;border-bottom-right-radius:5px}`;
import { sortObjects } from "../../omni-util.js";
class OmniTableElement extends OmniElement {
  constructor() {
    super();
    this.#firstUpdateCompleted = false;
    this._treeSet = /* @__PURE__ */ new Set();
    this._highlightSet = /* @__PURE__ */ new Set();
    this._hoverSet = /* @__PURE__ */ new Set();
    this._nestedDataExists = false;
    this.nestedIndent = 10;
    this.expandAllOnLoad = false;
    this.hideNestedIndent = false;
    this.columns = [];
    this.data = [];
    this.sort = {};
    this.#defaultKeyFn = (row) => {
      const isMainKey = this.columns.find((one) => one.isMain)?.key;
      const firstColumnKey = this.columns.find((one) => one.key)?.key;
      return row[isMainKey] ?? row[firstColumnKey] ?? row;
    };
    this.keyFn = this.#defaultKeyFn;
  }
  static get styles() {
    return [...super.styles, styles];
  }
  #firstUpdateCompleted;
  #defaultKeyFn;
  async willUpdate(changed) {
    if (changed.has("data")) {
      this._nestedDataExists = this.data.some((val) => val.nestedData);
      if (this._nestedDataExists && this.expandAllOnLoad && !this.#firstUpdateCompleted) {
        this.expandAll();
      }
      this.#firstUpdateCompleted = true;
    }
  }
  get _headersTemplate() {
    const columns = this.columns.map((column) => {
      const { key, dir } = this.sort;
      const isUp = dir === "asc" && key === column.key || dir === "desc" && key !== column.key;
      const sortIconId = `omni:interactive:${isUp ? "up" : "down"}`;
      return html`
        <th
          align
          part="th table-header-cell table-header-${column.key}"
          @click="${this._headerCellClicked}"
          class="${classMap({
        "is-clamped": true,
        "is-uppercase": true,
        "is-size-6": true,
        "is-sortable": column.isSortable ? true : false,
        "is-sorted": column.key ? key === column.key : false
      })}"
          data-key="${ifDefined(column.key)}">
          <span part="th-content">${column.label}</span>
          ${column.isSortable ? html`<omni-icon class="is-size-4" icon-id="${sortIconId}"></omni-icon>` : nothing}
        </th>
      `;
    });
    return columns;
  }
  get _rowsTemplate() {
    return repeat(this.data, this.keyFn, (row, idx) => this._buildRow(row, idx));
  }
  _buildRow(row, idx, level = 0) {
    const id = typeof this.keyFn(row) === "string" || typeof this.keyFn(row) === "number" ? String(this.keyFn(row)) : `L${level}-I${idx}`;
    return html`
      <tr
        part="table-body-row"
        class="${row.highlight || this._highlightSet.has(this.keyFn(row)) ? "highlight" : ""} ${this._hoverSet.has(
      this.keyFn(row)
    ) ? "is-hovered" : ""}"
        id=${id}
        @mouseover=${() => this.dispatchNewEvent("hover-row-enter", { detail: row })}
        @mouseout=${() => this.dispatchNewEvent("hover-row-exit", { detail: row })}>
        ${this.columns.map((column, cIdx) => this._cellTemplate(row, idx, column, cIdx, level))}
      </tr>
      ${row.nestedData && this._treeSet.has(this.keyFn(row)) ? repeat(row.nestedData, this.keyFn, (nRow, nIdx) => this._buildRow(nRow, nIdx, level + 1)) : nothing}
    `;
  }
  _cellTemplate(row, idx, column, cIdx, level) {
    let value = column.passthrough ? row : row[column.key];
    if (value === null || value === void 0)
      value = column.default;
    value = column.format ? column.format(value, idx) : value;
    if (this._nestedDataExists && cIdx === 0 && !this.hideNestedIndent) {
      const expandCellConfig = {
        row,
        level,
        template: column.template ? column.template(value, idx) : html`<span part="td-content" class="expand-content">${value}</span>`,
        shouldClamp: column.isClamped ?? true,
        isMain: column.isMain
      };
      return this.#expandCollapseCellTemplate(expandCellConfig);
    }
    if (column.template) {
      return column.template(value, idx);
    }
    return html`
      <td
        part="td table-body-cell table-body-${column.key}"
        class="${classMap({
      "is-clamped": column.isClamped ?? true,
      "is-main": column.isMain
    })}">
        <span part="td-content">${value}</span>
      </td>
    `;
  }
  #expandCollapseCellTemplate({ row, level, template, shouldClamp, isMain }) {
    const leftbar = (color) => html` <span class="leftbar" style="background-color: ${color}"></span> `;
    return html`
      <td
        class="expand ${isMain ? "is-main" : ""}"
        part="td-expand-collapse-level-${level}-${row.nestedData ? "has-children" : "no-children"}">
        ${row.leftbar ? leftbar(row.leftbar) : nothing}
        <div
          class="expand-wrapper ${shouldClamp ? "is-clamped" : ""}"
          style="margin-left: ${level * this.nestedIndent + "px"}">
          ${row.nestedData ? html`
                <button
                  class="button is-text is-stateless"
                  alt="Indicator to expand or collapse nested rows"
                  @click=${() => this.#toggleShowHideChildren(row)}>
                  <omni-icon
                    class="is-size-1"
                    icon-id="omni:interactive:${this._treeSet.has(this.keyFn(row)) ? "up" : "down"}"></omni-icon>
                </button>
              ` : html`<div class="expand-spacer"></div>`}
          ${template}
        </div>
      </td>
    `;
  }
  _findColumn(col, key) {
    return col.isSortable && col.key === key;
  }
  _headerCellClicked(e) {
    const { key = "" } = e.currentTarget.dataset;
    if (!key) {
      return;
    }
    const column = this.columns.find((col) => this._findColumn(col, key));
    if (!column) {
      return;
    }
    if (key === this.sort.key) {
      this.sort = { ...this.sort, dir: this.sort.dir === "asc" ? "desc" : "asc" };
    } else {
      this.sort = { ...this.sort, key, dir: "asc" };
    }
    let evtDetail = { detail: { ...this.sort } };
    if (this._nestedDataExists) {
      evtDetail = { detail: { sort: this.sort, data: this.data } };
    }
    this.dispatchNewEvent("sort", evtDetail);
  }
  #toggleShowHideChildren(row) {
    this._treeSet.has(this.keyFn(row)) ? this._treeSet.delete(this.keyFn(row)) : this._treeSet.add(this.keyFn(row));
    this._treeSet = new Set(this._treeSet);
    this.dispatchNewEvent("expand-or-collapse-rows", { detail: row });
  }
  /** returns a flat array of the passed table data */
  #flatten(data) {
    const flattened = [];
    const walk = (levelData) => {
      for (const row of levelData) {
        flattened.push(row);
        if (row.nestedData) {
          walk(row.nestedData);
        }
      }
    };
    walk(data);
    return flattened;
  }
  /** toggle the highlight for a given row	*/
  toggleRowHighlight(row) {
    this._highlightSet.has(this.keyFn(row)) ? this._highlightSet.delete(this.keyFn(row)) : this._highlightSet.add(this.keyFn(row));
    this._highlightSet = new Set(this._highlightSet);
  }
  toggleRowExpansion(row) {
    this._treeSet.has(this.keyFn(row)) ? this._treeSet.delete(this.keyFn(row)) : this._treeSet.add(this.keyFn(row));
    this._treeSet = new Set(this._treeSet);
  }
  /** if children exist, expands rows for provided array of rows	*/
  expandRows(rows) {
    rows.forEach((row) => this._treeSet.add(this.keyFn(row)));
    this._treeSet = new Set(this._treeSet);
    this.dispatchNewEvent("expand-or-collapse-rows");
  }
  /**if children exist, collapse rows for provided array of rows	*/
  collapseRows(rows) {
    rows.forEach((row) => this._treeSet.delete(this.keyFn(row)));
    this._treeSet = new Set(this._treeSet);
    this.dispatchNewEvent("expand-or-collapse-rows");
  }
  /** collapse all rows with nested data */
  collapseAll() {
    this.collapseRows(this.#flatten(this.data));
  }
  /** expand all rows with nested data */
  expandAll() {
    this.expandRows(this.#flatten(this.data));
  }
  toggleRowHover(row) {
    this._hoverSet.has(this.keyFn(row)) ? this._hoverSet.delete(this.keyFn(row)) : this._hoverSet.add(this.keyFn(row));
    this._hoverSet = new Set(this._hoverSet);
  }
  hoverRow(row) {
    this._hoverSet.add(this.keyFn(row));
    this._hoverSet = new Set(this._hoverSet);
  }
  removeHoverRow(row) {
    this._hoverSet.delete(this.keyFn(row));
    this._hoverSet = new Set(this._hoverSet);
  }
  render() {
    return html`
      <omni-style>
        <div class="table-container" part="table-container">
          <table part="table" class="table is-fullwidth is-hoverable">
            <thead part="table-header">
              <tr part="table-header-row" class="header">
                ${this._headersTemplate}
              </tr>
            </thead>
            <tbody part="table-body">
              ${this._rowsTemplate}
            </tbody>
          </table>
          <div id="table-footer">
            <slot name="table-footer"></slot>
          </div>
        </div>
      </omni-style>
    `;
  }
}
__decorateClass([
  state()
], OmniTableElement.prototype, "_treeSet", 2);
__decorateClass([
  state()
], OmniTableElement.prototype, "_highlightSet", 2);
__decorateClass([
  state()
], OmniTableElement.prototype, "_hoverSet", 2);
__decorateClass([
  state()
], OmniTableElement.prototype, "_nestedDataExists", 2);
__decorateClass([
  property({ type: Number })
], OmniTableElement.prototype, "nestedIndent", 2);
__decorateClass([
  property({ attribute: false })
], OmniTableElement.prototype, "keyFn", 2);
__decorateClass([
  property({ type: Boolean })
], OmniTableElement.prototype, "expandAllOnLoad", 2);
__decorateClass([
  property({ type: Boolean })
], OmniTableElement.prototype, "hideNestedIndent", 2);
__decorateClass([
  property({ type: Array, attribute: false })
], OmniTableElement.prototype, "columns", 2);
__decorateClass([
  property({ type: Array, attribute: false })
], OmniTableElement.prototype, "data", 2);
__decorateClass([
  property({ type: Object, attribute: false })
], OmniTableElement.prototype, "sort", 2);
OmniElement.register("omni-table", OmniTableElement);
function handleNestedDataSort({ detail: { data, sort } }) {
  const sortLevel = (levelData) => {
    const sortedData2 = sortObjects(levelData, sort.key);
    if (sort.dir === "desc") {
      sortedData2.reverse();
    }
    for (const obj of sortedData2) {
      if (obj.nestedData) {
        obj.nestedData = sortLevel(obj.nestedData);
      }
    }
    return sortedData2;
  };
  const sortedData = sortLevel(data);
  return { data: sortedData, sort };
}
export {
  OmniTableElement,
  handleNestedDataSort
};
//# sourceMappingURL=omni-table.js.map
