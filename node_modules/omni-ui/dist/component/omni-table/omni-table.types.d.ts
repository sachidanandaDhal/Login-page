import type { TemplateResult } from 'lit';
export interface TableColumn {
    /** Name of the column to display in the table header*/
    label: string | TemplateResult;
    /** key of the data object to display in the cell. each column key must be unique */
    key?: string;
    /** a default value to use if data does not contain a value for given key*/
    default?: string;
    /** Boolean representing if sort direction arrows should be displayed */
    isSortable?: boolean;
    /** Boolean representing if column should be treated as the primary column (bolded text, hover state); */
    isMain?: boolean;
    /** override 'is-clamped' class for a <td> cell with `isClamped: false` */
    isClamped?: boolean;
    /** Boolean representing if value should be passed as the entire row object */
    passthrough?: boolean;
    /** function to customize the table cell render. Make sure to include the <td> element. In nested table, do not wrap with <td> */
    template?: (...args: any[]) => unknown;
    /** function to use to format the raw data value before displaying it in the table */
    format?: (...args: any[]) => unknown;
}
export type TableRow = Record<string, unknown>;
export type TableData = TableRow[];
export interface Sort {
    /**
     * key of the column that is being sorted
     */
    key: string;
    /**
     * 'asc' or 'desc', direction of sort
     */
    dir: 'asc' | 'desc';
}
export interface NestedDataSortDetail {
    data: TableData;
    sort: Sort;
}
export type KeyFn = (row: TableRow) => string | number | TableRow;
//# sourceMappingURL=omni-table.types.d.ts.map