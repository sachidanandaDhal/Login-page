var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
import { property } from "lit/decorators.js";
import { OmniElement } from "../../omni-element.js";
import { OmniOverlay } from "../omni-overlay/omni-overlay.js";
import "./omni-tooltip-overlay.js";
import { css } from "lit";
const styles = css`:host{display:inline-block;contain:strict style}slot[name=invoker]::slotted([disabled]){pointer-events:none}[tooltip],slot[name=content],slot[name=content]::slotted(*){display:none}`;
const _OmniTooltipElement = class _OmniTooltipElement extends OmniElement {
  constructor() {
    super();
    /** @internal */
    this.__id = `_tooltip${_OmniTooltipElement.count}_`;
    this.#mutationConfig = { attributes: true, childList: true, subtree: true };
    this.showOnDisabled = false;
    this.relateby = "describe";
    this.place = "top";
    this.#mutation = (mutationList) => {
      mutationList.forEach((m) => {
        if (m.type === "attributes") {
          const target = m.target;
          if (m.attributeName === "disabled" && target.slot === "invoker") {
            this.disabled = target.disabled;
          }
        }
      });
    };
    this.attachShadow({ mode: "open" }).innerHTML = `
			<slot name="invoker"></slot>
			<slot name="content"></slot>
			<omni-tooltip-overlay slot="indicator" tooltip></omni-tooltip-overlay>
		`;
    const { shadowRoot } = this;
    this.tooltip = shadowRoot.querySelector("[tooltip]");
    this.tooltip.origin = this;
    this.content = shadowRoot.querySelector('slot[name="content"]');
    this.invoker = shadowRoot.querySelector('slot[name="invoker"]');
    shadowRoot.querySelectorAll("slot").forEach((node) => node.addEventListener("slotchange", this._slotchange.bind(this)));
    this._show = this._show.bind(this);
    this._hide = this._hide.bind(this);
    this.tooltip.remove();
    this.tooltip.addEventListener("overlay-remove", this._hide);
    this.addEventListener("mouseenter", this._show);
    this.addEventListener("focusin", this._show);
    this.addEventListener("mouseleave", this._hide);
    this.addEventListener("click", this._hide);
    this.addEventListener("focusout", this._hide);
  }
  static get styles() {
    return [...super.styles, styles];
  }
  static get count() {
    const count = this.#count ?? 0;
    this.#count = count + 1;
    return this.#count;
  }
  static #count;
  #observer;
  #mutationConfig;
  connectedCallback() {
    super.connectedCallback();
    OmniOverlay.overlay;
    const invoker = this.invoker.assignedElements()[0];
    if (invoker) {
      this.#observer = new MutationObserver(this.#mutation);
      this.#observer.observe(invoker, this.#mutationConfig);
    }
    if (this.open) {
      requestAnimationFrame(() => {
        this._show();
      });
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this._hide();
    if (this.#observer) {
      this.#observer?.disconnect();
    }
  }
  #mutation;
  get noflip() {
    return this.hasAttribute("noflip");
  }
  set noflip(flag) {
    flag ? this.setAttribute("noflip", "") : this.removeAttribute("noflip");
  }
  _show() {
    if (this.disabled && !this.showOnDisabled)
      return;
    this.open = true;
  }
  _hide() {
    this.open = false;
    this.event?.stopImmediatePropagation();
    requestAnimationFrame(() => {
      this.tooltip.remove();
      Array.from(this.tooltip.children).forEach((node) => this.appendChild(node));
    });
  }
  _attr(node, attr = "attr", value = "") {
    if (!node.hasAttribute(attr)) {
      node.setAttribute(attr, value);
    }
  }
  fakePromise() {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(true);
      }, 0);
    });
  }
  isContentEmpty() {
    if (!this.content.assignedElements().length) {
      this._hide();
      return true;
    } else {
      let checkInnerContentText = false;
      this.content.assignedElements().forEach((node) => {
        const _node = node;
        if (_node.innerText.trim())
          checkInnerContentText = true;
      });
      if (!checkInnerContentText) {
        this._hide();
        return true;
      }
      return false;
    }
  }
  async updated(changedProperties) {
    const styles2 = getComputedStyle(this);
    if (changedProperties.has("disabled") || changedProperties.has("showOnDisabled")) {
      this._hide();
    } else if (changedProperties.has("open")) {
      const eventListenerOptions = { capture: true, once: true };
      const { open } = this;
      if (open) {
        const { tooltip, className } = this;
        tooltip.className = className;
        tooltip.noflip = this.noflip;
        if (this.isContentEmpty())
          return;
        await this.fakePromise();
        this.content.assignedElements().forEach((node) => tooltip.appendChild(node));
        const { width, height, x, y } = this.getBoundingClientRect();
        const { style } = tooltip;
        style.setProperty("--trigger-width", `${Math.round(width)}px`);
        style.setProperty("--trigger-height", `${Math.round(height)}px`);
        style.setProperty("--trigger-top", `${Math.round(y)}px`);
        style.setProperty("--trigger-left", `${Math.round(x)}px`);
        style.setProperty("--tooltip-background-color", styles2.getPropertyValue("--tooltip-background-color"));
        style.setProperty("--tooltip-text-color", styles2.getPropertyValue("--tooltip-text-color"));
        this.event = new CustomEvent("overlay", {
          detail: this.tooltip,
          bubbles: true,
          composed: true
        });
        this.dispatchEvent(this.event);
        self.addEventListener("mousewheel", this._hide, eventListenerOptions);
        self.addEventListener("keydown", this._hide, eventListenerOptions);
        this.tooltip.setAttribute("place", this.place);
      } else {
        self.removeEventListener("mousewheel", this._hide, eventListenerOptions);
        self.removeEventListener("keydown", this._hide, eventListenerOptions);
        this._hide();
      }
    } else if (changedProperties.has("place")) {
      this.tooltip.setAttribute("place", this.place);
    }
  }
  _slotchange({ target }) {
    const nodes = target.assignedElements();
    const [firstElement] = nodes;
    if (!firstElement)
      return;
    switch (target.name) {
      case "invoker":
        if (firstElement.disabled) {
          this.disabled = true;
        }
        this._attr(firstElement, this.relateby.includes("label") ? "aria-labelledby" : "aria-describedby", this.__id);
        break;
      case "content":
        this._attr(firstElement, "role", "tooltip");
        this._attr(firstElement, "id", this.__id);
        this.requestUpdate();
        break;
    }
  }
};
__decorateClass([
  property({ type: Boolean, reflect: true })
], _OmniTooltipElement.prototype, "open", 2);
__decorateClass([
  property({ type: Boolean, reflect: true })
], _OmniTooltipElement.prototype, "disabled", 2);
__decorateClass([
  property({ type: Boolean, reflect: true, attribute: "show-on-disabled" })
], _OmniTooltipElement.prototype, "showOnDisabled", 2);
__decorateClass([
  property({ type: String })
], _OmniTooltipElement.prototype, "relateby", 2);
__decorateClass([
  property({ type: String, reflect: true })
], _OmniTooltipElement.prototype, "place", 2);
let OmniTooltipElement = _OmniTooltipElement;
OmniElement.register("omni-tooltip", OmniTooltipElement);
export {
  OmniTooltipElement
};
//# sourceMappingURL=omni-tooltip.js.map
