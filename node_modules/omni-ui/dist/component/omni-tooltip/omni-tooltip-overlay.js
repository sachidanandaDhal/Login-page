import { OmniElement } from "../../omni-element.js";
class OmniTooltipOverlay extends OmniElement {
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  render() {
  }
  constructor() {
    super();
    this.attachShadow({ mode: "open" }).innerHTML = `
      <style>
        :host {
          contain: strict style;
          display: block;
          pointer-events:none;
          position:fixed;
          background-color:rgba(255, 255, 0, 0);
          top: var(--trigger-top, 0px);
          left: var(--trigger-left, 0px);
          --arrow-size: 8px;
          --tooltip-width: 2em;
          --tooltip-height: 2em;
          --trigger-width: 1em;
          --trigger-height: 1em;
          --tooltip-background-color: linear-gradient(to bottom, #2b3952, #142033 100%);
          --tooltip-text-color: white;
          width: var(--trigger-width, 1em);
          height: var(--trigger-height, 1em);
        }
        :host([disabled]) [tooltip]:focus-visible {
          outline: none;
          pointer-events: none;
        }

        @keyframes fade-in {
          0% {
            opacity: 0;
          }
          50% {
            opacity: 0;
          }
          100% {
            opacity: 1;
          }
        }

        [intersect] {
          --width: min(var(--tooltip-width), var(--trigger-width));
          --height: min(var(--tooltip-height), var(--trigger-height));
          --width: var(--tooltip-width);
          --height: var(--tooltip-height);
          position: absolute;
          top: calc(50% - var(--height, 0px) / 2);
          left: calc(50% - var(--width, 0px) / 2);
          background-color: rgba(0, 255, 255, 0);
          display: block;
          width: var(--width,1vw);
          height: var(--height,1vh);
          pointer-events: none;
        }
        [intersect]:where([area=left], [area=right]) {
          width: 48vw;
          left: calc(50% - 48vw);
        }
        [intersect]:where([area=right]){
          left: calc(50%);
          background-color: rgba(0, 0, 255, 0);
        }
        [intersect]:where([area=top], [area=bottom]) {
          height: 48vh;
          top: calc(50% - 48.5vh);
          background-color: rgba(200, 255, 0, 0);
        }
        [intersect]:where([area=bottom]) {
          top: calc(50% - 0.5vh);
          background-color: rgba(0, 255, 0, 0);
        }

        [tooltip] {
          box-sizing: border-box;
          min-width: 2em;
          min-height: 2em;
          max-width: 40em;
          max-height: 40em;
          position: fixed;
          animation: 400ms ease-in 1 fade-in;
          background: var(--tooltip-background-color);
          border-radius: 8px;
          color: var(--tooltip-text-color);
          padding: 7px 15px;
          font-size: 12px;
          font-weight: 600;
          text-align: left;
          pointer-events: none;
          overflow-wrap: break-word;
          --offset-top: calc((var(--trigger-height) - var(--tooltip-height)) / 2);
          --offset-left: calc((var(--trigger-width) - var(--tooltip-width)) / 2);
        }

        :host(.is-light) [tooltip] {
          background: white;
          color: var(--color-almost-black);
        }
        :host([tip-flip='top']) [tooltip],
        :host([tip-flip='bottom']) [tooltip],
        :host([place='bottom']:not([tip-flip])) [tooltip],
        :host([place='top']:not([tip-flip])) [tooltip] {
          left: calc(var(--trigger-left) + var(--offset-left));
          top: calc(var(--trigger-top, 0px) - var(--tooltip-height, 0px) - var(--arrow-size));
        }
        :host([tip-flip='bottom']) [tooltip],
        :host([place='bottom']:not([tip-flip])) [tooltip] {
          top: calc(var(--trigger-top, 0px) + var(--trigger-height, 0px) + var(--arrow-size));
        }
        :host(:where([tip-flip='right'], [tip-flip="left"])) [tooltip],
        :host([place='right']:not([tip-flip])) [tooltip],
        :host([place='left']:not([tip-flip])) [tooltip] {
          left: calc(var(--trigger-left, 0px) - var(--tooltip-width, 0px) - var(--arrow-size));
          top: calc(var(--trigger-top, 0px) + var(--offset-top, 0px));
        }
        :host([tip-flip='right']) [tooltip],
        :host([place='right']:not([tip-flip])) [tooltip] {
          left: calc(var(--trigger-left, 0px) + var(--trigger-width, 0px) + var(--arrow-size));
        }

        #arrow {
          position: absolute;
          width: var(--arrow-size, 8px);
          height: var(--arrow-size, 8px);
          z-index: -1;
          content: '';
          transform: rotate(45deg);
          background: inherit;
        }

        :host(:where([tip-flip='top'], [tip-flip='bottom'])) #arrow,
        :host(:where([place='top'], [place='bottom']):not([tip-flip])) #arrow {
          left: calc(50% - 4px);
          bottom: -4px;
          top: auto;
        }
        :host(:where([tip-flip='bottom'])) #arrow,
        :host([place='bottom']:not([tip-flip])) #arrow {
          bottom: auto;
          top: -4px;
        }
        :host(:is([tip-flip="left"], [tip-flip="right"])) #arrow,
        :host(:is([place='left'], [place='right']):not([tip-flip])) #arrow {
          top: calc(50% - 4px);
          left: auto;
          right: -4px;
        }
        :host([tip-flip='right']) #arrow,
        :host([place='right']:not([tip-flip])) #arrow {
          right: auto;
          left: -4px;
        }
      </style>
      <div intersect area=top> </div>
      <div intersect area=right> </div>
      <div intersect area=bottom> </div>
      <div intersect area=left> </div>
      <div tooltip part="tooltip">
        <slot name="content">...</slot>
        <div id="arrow" part="arrow"></div>
      </div>
    `;
    this.tooltip = this.shadowRoot.querySelector("[tooltip]");
    this.intersect = this.shadowRoot.querySelectorAll("[intersect]");
    this._resizeObserver = new ResizeObserver((...args) => {
      cancelAnimationFrame(this.__resized);
      this.__resized = requestAnimationFrame(() => {
        this._resize(...args);
      });
    });
    this._intersectObserver = new IntersectionObserver(
      (...args) => {
        this._intersect(...args);
      },
      { root: null, rootMargin: `0px`, threshold: 1 }
    );
    this._area = { top: 1, right: 1, bottom: 1, left: 1 };
    this._arealist = Object.keys(this._area);
  }
  connectedCallback() {
    super.connectedCallback();
    const { tooltip, intersect, _resizeObserver, _intersectObserver } = this;
    _resizeObserver.observe(tooltip);
    if (this.noflip)
      return;
    _intersectObserver.observe(tooltip);
    intersect.forEach((node) => _intersectObserver.observe(node));
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeAttribute("tip-flip");
    this._resizeObserver.disconnect();
    this._intersectObserver.disconnect();
  }
  _reposition(intersectionRatio) {
    const { place, _area } = this;
    const min = 0.99;
    if (intersectionRatio < 1) {
      const { _arealist } = this;
      const flippedinto = this.getAttribute("tip-flip");
      const index = _arealist.indexOf(flippedinto || place);
      let position;
      let i = index + 2;
      let available;
      if (i >= _arealist.length) {
        i -= _arealist.length;
      }
      available = _area[_arealist[i]];
      if (available > min) {
        position = _arealist[i];
      }
      i = index + 1;
      const race = [];
      while (!position) {
        const note = { i, index };
        race.push(note);
        if (i === index || race.length > 12) {
          position = place;
          break;
        } else if (i >= _arealist.length) {
          note.loop = "i=0";
          i = 0;
        }
        available = _area[_arealist[i]];
        if (available > min) {
          position = _arealist[i];
          break;
        }
        i += 1;
      }
      if (race.length > 4) {
        console.warn(`
          \u{1F447} please send to omni-ui:

            url: ${location.href}
            user-agent: "${navigator.userAgent}"
            log>>
              ${JSON.stringify(race)}
            <<
            html: ${this.outerHTML}

          \u261D\uFE0F please send to omni-ui.
        `);
      }
      if (position === place) {
        this.removeAttribute("tip-flip");
      } else {
        this.setAttribute("tip-flip", position);
      }
    } else {
      if (_area[place] > min) {
        this.removeAttribute("tip-flip");
      }
    }
  }
  _intersectItem(entry) {
    const { target, intersectionRatio } = entry;
    const { _area } = this;
    if (target.matches("[tooltip]")) {
      this._intersectObserver.disconnect();
      cancelAnimationFrame(this.__repositioning);
      this.__repositioning = requestAnimationFrame(() => {
        this._reposition(intersectionRatio);
      });
    } else if (target.matches("[intersect]")) {
      const area = target.getAttribute("area");
      _area[area] = intersectionRatio;
    }
  }
  get place() {
    return this.getAttribute("place");
  }
  set place(place) {
    const value = this._area[place] !== void 0 ? place : "top";
    this.setAttribute("place", value);
  }
  _intersect(entries) {
    cancelAnimationFrame(this.__intersecting);
    this.__intersecting = requestAnimationFrame(() => {
      entries.forEach(this._intersectItem, this);
    });
  }
  _resize(entries) {
    cancelAnimationFrame(this.__resizing);
    this.__resizing = requestAnimationFrame(() => {
      entries.forEach(this._resizedItem, this);
    });
  }
  _resizedItem(entry) {
    const { target, borderBoxSize } = entry;
    const { inlineSize, blockSize, width, height } = borderBoxSize?.[0] ?? target.getBoundingClientRect();
    const w = inlineSize ?? width;
    const h = blockSize ?? height;
    if (!w || !h)
      return;
    const { style } = this;
    style.setProperty("--tooltip-width", `${Math.round(w)}px`);
    style.setProperty("--tooltip-height", `${Math.round(h)}px`);
  }
}
OmniElement.register("omni-tooltip-overlay", OmniTooltipOverlay);
export {
  OmniTooltipOverlay
};
//# sourceMappingURL=omni-tooltip-overlay.js.map
