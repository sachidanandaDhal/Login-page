var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
import { html } from "lit";
import { property, query, state } from "lit/decorators.js";
import { OmniElement } from "../../omni-element.js";
import { ElementInternalsBase } from "../../element-internals-base.js";
import { css } from "lit";
const styles = css`:host{--range-slider-background: var(--gradient-primary);--range-slider-thumb-border: var(--color-secondary);display:flex;flex-direction:column}:host(:focus-visible){outline:var(--color-secondary) solid 1px}:host([disabled]){--cursor-state: not-allowed;--pointer-state: none;opacity:.45;cursor:not-allowed}[slider]{position:relative;border-radius:0.7142857143rem;text-align:left;padding:0 0.5714285714rem}[slider] #sign-container{display:flex;justify-content:space-between;align-items:center;padding:0;margin:0 -0.5714285714rem}[slider] #sign-container div{display:flex}[slider] #sign-container div[sign]{color:var(--color-almost-black);width:1.4285714286rem;border-radius:0.2857142857rem;align-items:center;justify-content:center;text-align:center;background-color:var(--color-white);margin-bottom:0.7142857143rem}[slider] #sign-container div[sign] span{font-size:0.8571428571rem}[slider] .slider-container{pointer-events:var(--pointer-state, all);position:relative;display:flex;justify-content:flex-start;align-items:center;padding:0 0 0.2857142857rem 0}[slider] .slider-container [left-track],[slider] .slider-container [right-track]{height:0.5714285714rem;border-radius:0.2857142857rem;border:1px solid var(--color-pale-grey-three);background:var(--color-white)}[slider] .slider-container [middle-track]{height:0.5714285714rem;background:var(--range-slider-background)}[slider] .slider-container [thumb]{position:absolute;top:-0.25rem;height:1.1428571429rem;width:1.1428571429rem;text-align:left;background:var(--range-slider-background);border-radius:50%;border:var(--range-slider-thumb-border) solid 1px}[slider] .slider-container [thumb]:active:not([disabled]){cursor:var(--cursor-state, grabbing)}[slider] .slider-container [thumb]:hover:not(:active,[disabled]){cursor:var(--cursor-state, grab)}[slider] .slider-container [thumb]:focus{outline:var(--range-slider-thumb-border) solid 1px}[slider] .slider-container [thumb][disabled]{cursor:not-allowed}`;
class OmniRangeSlider extends ElementInternalsBase {
  constructor() {
    super(...arguments);
    this.#resizeObserver = new ResizeObserver(
      (entries) => this.#positionElements(entries[0].contentRect)
    );
    this.#originalBodyStyle = "";
    this.min = 0;
    this.max = 100;
    this.step = 1;
    this.valueMissingMessage = "Please select a range";
    this.numberFormatOptions = {
      locale: "en-US",
      options: {}
    };
    this.value = {
      min: 0,
      max: 100
    };
    this.#blur = () => {
      this.blur();
      this.leftThumbEl.blur();
      this.rightThumbEl.blur();
    };
    /** if mousedown, and target is a thumb, this method will shift the thumb up or down one step at a time  */
    this.#handleMousemove = (e) => {
      const hostRect = this.getBoundingClientRect();
      if (this.#whichActiveThumb === "min") {
        const moveDiff = e.clientX - hostRect.left;
        const decimal = moveDiff / this.clientWidth;
        const value = decimal * (this.max - this.min) + this.min;
        const roundedValue = Number((Math.round(value / this.step) * this.step).toFixed(2));
        if (!this.#isValidChange(roundedValue))
          return;
        this.value.min = roundedValue;
      } else {
        const moveDiff = hostRect.right - e.clientX;
        const decimal = moveDiff / this.clientWidth;
        const value = this.max - decimal * (this.max - this.min);
        const roundedValue = Number((Math.round(value / this.step) * this.step).toFixed(2));
        if (!this.#isValidChange(roundedValue))
          return;
        this.value.max = roundedValue;
      }
      this.#positionElements(hostRect);
    };
    /** sets the active thumb, adds event listeners, and modifies body css for accurate cursor */
    this.#handleMousedown = (e) => {
      this.#whichActiveThumb = e.target.hasAttribute("left") ? "min" : "max";
      this.#originalBodyStyle = document.body.style.cssText;
      document.body.style.cursor = "grabbing";
      document.body.style.userSelect = "none";
      document.body.style["-webkit-user-select"] = "none";
      document.addEventListener("mousemove", this.#handleMousemove);
      document.addEventListener("mouseup", this.#handleMouseup);
    };
    /** sets body css to original, removes event listeners, and emits change event*/
    this.#handleMouseup = () => {
      document.removeEventListener("mousemove", this.#handleMousemove);
      document.removeEventListener("mouseup", this.#handleMouseup);
      document.body.style.cssText = this.#originalBodyStyle;
      this.#emitChange();
    };
  }
  static get styles() {
    return [...super.styles, styles];
  }
  #resizeObserver;
  #originalBodyStyle;
  #whichActiveThumb;
  #formatter;
  connectedCallback() {
    super.connectedCallback();
    this.#resizeObserver.observe(this);
    this.#formatter = new Intl.NumberFormat(this.numberFormatOptions.locale, this.numberFormatOptions.options);
  }
  async firstUpdated() {
    await this.updateComplete;
    if (this.required) {
      this._internals.setFormValue(JSON.stringify(this.value));
      if (!this.value) {
        this._internals.setValidity({ valueMissing: true }, this.valueMissingMessage, this.containerEl);
      }
    }
    this.#positionElements(this.getBoundingClientRect());
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.#resizeObserver.unobserve(this);
  }
  #isValidChange(value) {
    if (this.#whichActiveThumb === "min") {
      if (value >= this.value.max)
        return false;
      if (value * 1e3 % (this.step * 1e3) !== 0)
        return false;
      if (value - this.value.max * -1 < this.step)
        return false;
      if (value < this.min)
        return false;
    } else {
      if (value <= this.value.min)
        return false;
      if (value * 1e3 % (this.step * 1e3) !== 0)
        return false;
      if (value - this.value.min < this.step)
        return false;
      if (value > this.max)
        return false;
    }
    return true;
  }
  #emitChange() {
    if (typeof this.value.min !== "undefined" && typeof this.value.max !== "undefined") {
      this._internals.setValidity({});
    }
    this._internals.setFormValue(JSON.stringify(this.value));
    this.dispatchNewEvent("change", {
      detail: this.value
    });
  }
  /** returns the fromLeft and fromRight as percentages */
  #calcPositions(value = this.value) {
    const totalRange = this.max - this.min;
    const leftBarLength = value.min;
    const middleBarLength = value.max - value.min;
    const rightBarLength = totalRange - leftBarLength - middleBarLength;
    const fromLeft = (leftBarLength / totalRange - this.min / totalRange) * 100;
    const fromRight = (rightBarLength / totalRange + this.min / totalRange) * 100;
    return {
      fromLeft,
      fromRight
    };
  }
  /**  calculates and updates the properties to position the bars and thumbs */
  #positionElements(hostRect) {
    const { fromLeft, fromRight } = this.#calcPositions();
    this._left = `${fromLeft}%`;
    this._right = `${fromRight}%`;
    this._leftThumb = `${fromLeft - this.leftThumbEl.clientWidth / hostRect.width / 2 * 100}%`;
    this._rightThumb = `${fromRight - this.rightThumbEl.clientWidth / hostRect.width / 2 * 100}%`;
  }
  /** if a thumb is DOM focused, this increments the focused thumb up or down based on the left or right arrow keys  */
  #handleKeydown(e) {
    const target = e.target;
    const key = e.key;
    if (key === "ArrowLeft" || key === "ArrowRight") {
      e.preventDefault();
      e.stopPropagation();
      const hostRect = this.getBoundingClientRect();
      this.#whichActiveThumb = target.hasAttribute("left") ? "min" : "max";
      if (this.#whichActiveThumb === "min") {
        if (key === "ArrowLeft") {
          this.#stepDownMin();
        } else {
          this.#stepUpMin();
        }
      } else {
        if (key === "ArrowLeft") {
          this.#stepDownMax();
        } else {
          this.#stepUpMax();
        }
      }
      this.#positionElements(hostRect);
      this.#emitChange();
    }
    if (e.key === "Escape") {
      this.#blur();
    }
  }
  #blur;
  #handleMousemove;
  #handleMousedown;
  #handleMouseup;
  #stepDownMin() {
    const value = this.value.min - this.step;
    if (!this.#isValidChange(value))
      return;
    this.value.min = value;
  }
  #stepUpMin() {
    const value = this.value.min + this.step;
    if (!this.#isValidChange(value))
      return;
    this.value.min = value;
  }
  #stepUpMax() {
    const value = this.value.max + this.step;
    if (!this.#isValidChange(value))
      return;
    this.value.max = value;
  }
  #stepDownMax() {
    const value = this.value.max - this.step;
    if (!this.#isValidChange(value))
      return;
    this.value.max = value;
  }
  /** programmatically step up one step */
  stepUp(thumb) {
    this.#whichActiveThumb = thumb;
    if (this.#whichActiveThumb === "min") {
      this.#stepUpMin();
    } else {
      this.#stepUpMax();
    }
    this.#positionElements(this.getBoundingClientRect());
    this.#emitChange();
  }
  /** programmatically step down one step */
  stepDown(thumb) {
    this.#whichActiveThumb = thumb;
    if (this.#whichActiveThumb === "min") {
      this.#stepDownMin();
    } else {
      this.#stepDownMax();
    }
    this.#positionElements(this.getBoundingClientRect());
    this.#emitChange();
  }
  render() {
    return html`
      <div slider id="slider-distance" @blur=${this.#blur}>
        <div id="sign-container">
          <div sign>
            <span>${this.#formatter.format(this.value.min)}</span>
          </div>
          <div sign>
            <span>${this.#formatter.format(this.value.max)}</span>
          </div>
        </div>
        <div class="slider-container">
          <div left-track style="flex: 0 0 ${this._left}"></div>
          <div middle-track style="flex-grow: 1"></div>
          <div right-track style="flex: 0 0 ${this._right}"></div>
          <span
            thumb
            left
            style="left:${this._leftThumb}"
            tabindex=${this.disabled ? "-1" : "0"}
            @mousedown=${this.#handleMousedown}
            @keydown=${this.#handleKeydown}>
          </span>
          <span
            thumb
            right
            style="right:${this._rightThumb}"
            tabindex=${this.disabled ? "-1" : "0"}
            @mousedown=${this.#handleMousedown}
            @keydown=${this.#handleKeydown}>
          </span>
        </div>
      </div>
    `;
  }
}
__decorateClass([
  state()
], OmniRangeSlider.prototype, "_left", 2);
__decorateClass([
  state()
], OmniRangeSlider.prototype, "_leftThumb", 2);
__decorateClass([
  state()
], OmniRangeSlider.prototype, "_right", 2);
__decorateClass([
  state()
], OmniRangeSlider.prototype, "_rightThumb", 2);
__decorateClass([
  property({ type: Number })
], OmniRangeSlider.prototype, "min", 2);
__decorateClass([
  property({ type: Number })
], OmniRangeSlider.prototype, "max", 2);
__decorateClass([
  property({ type: Number })
], OmniRangeSlider.prototype, "step", 2);
__decorateClass([
  property({ type: String })
], OmniRangeSlider.prototype, "name", 2);
__decorateClass([
  property({ type: String })
], OmniRangeSlider.prototype, "valueMissingMessage", 2);
__decorateClass([
  property({ type: Object })
], OmniRangeSlider.prototype, "numberFormatOptions", 2);
__decorateClass([
  property({ type: Object, reflect: true })
], OmniRangeSlider.prototype, "value", 2);
__decorateClass([
  query(".slider-container")
], OmniRangeSlider.prototype, "containerEl", 2);
__decorateClass([
  query("[thumb][left]")
], OmniRangeSlider.prototype, "leftThumbEl", 2);
__decorateClass([
  query("[thumb][right]")
], OmniRangeSlider.prototype, "rightThumbEl", 2);
OmniElement.register("omni-range-slider", OmniRangeSlider);
export {
  OmniRangeSlider
};
//# sourceMappingURL=omni-range-slider.js.map
