import { ElementInternalsBase } from '../../element-internals-base.js';
interface RadioElement {
    /**
     * in a regular radio, the checked attribute does not override the checked property
     * here, we can have both work
     */
    checked: boolean;
    /** check the box */
    check: () => void;
    /** uncheck the box */
    uncheck: () => void;
    /** toggle the check  */
    toggle: () => void;
}
/**
 * To include within your project `import { OmniRadio } from 'omni-ui';`
 *
 * @slot - label slot for radio
 * @tagname omni-radio
 * @cssprop [--radio-height-width=1.2857rem]
 * @cssprop [--radio-border-width=calc(var(--radio-height-width) / 9)]
 * @cssprop [--radio-background=var(--color-almost-black)]
 * @cssprop [--radio-background-hover=var(--color-primary)]
 * @cssprop [--radio-background-error=var(--color-error)]
 * @cssprop [--radio-font-color=var(--color-almost-black)]
 */
export declare class OmniRadio extends ElementInternalsBase<string> implements RadioElement {
    #private;
    static get styles(): import("lit").CSSResult[];
    valueMissingMessage: string;
    checked: boolean;
    error: string;
    name: string;
    /** can only be set as a string. If other data types are desired, stringify your data and set it to value, then parse on read */
    value: string;
    showfooter: boolean;
    /**
     * @internal
     */
    radioEl: HTMLElement;
    /**
     * @internal
     */
    slottedElements: HTMLElement[];
    connectedCallback(): void;
    disconnectedCallback(): void;
    firstUpdated(): Promise<void>;
    updated(): void;
    /**
     * @internal
     */
    _handleKeyup: (e: KeyboardEvent) => void;
    toggle(): void;
    check(): void;
    uncheck(): void;
    render(): import("lit-html").TemplateResult<1>;
}
export {};
//# sourceMappingURL=omni-radio.d.ts.map