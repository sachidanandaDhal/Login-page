class Color {
  static number(input, relativeTo = 1) {
    let n;
    if (typeof input === "string" && input.endsWith("%")) {
      n = (Number(input.slice(0, -1)) || 0) / 100 * relativeTo;
    } else {
      n = Number(input) || 0;
    }
    return n;
  }
  /*
         parse input to an expected color dictionary describing a color
         @param {object|string} input - like css strings 'rgb(0,0,0)' 'hsl(1turn, 50%, 50% / 0.5)' '#11223344' and objects {r:255,g:255,b:255} from vanilla-colorful picker events for various types
         @returns {type: 'rgb|hsl', r, g, b, h, s, l, a, grad: 'deg|grad|rad|turn'} with whatever values correlate, all number values on properties except type (and angle for hsl)
       */
  static parse(input) {
    let output = {};
    let alpha;
    if (typeof input === "object") {
      const { r, g, b, h, s, l, a, angle = "deg" } = input;
      if (typeof r === "number") {
        output = { r, g, b, a };
      } else if (typeof h === "number") {
        output = { h, s, l, a, angle };
      }
    } else if (typeof input === "string") {
      const txt = input.trim();
      let r;
      let g;
      let b;
      let a;
      if (txt.startsWith("#")) {
        const size = txt.length;
        if (size <= 5) {
          r = Color.number(`0x${txt[1]}${txt[1]}`);
          g = Color.number(`0x${txt[2]}${txt[2]}`);
          b = Color.number(`0x${txt[3]}${txt[3]}`);
          if (size > 4)
            a = Color.number(`0x${txt[4]}${txt[4]}`) / 255;
        } else {
          r = Color.number(`0x${txt[1]}${txt[2]}`);
          g = Color.number(`0x${txt[3]}${txt[4]}`);
          b = Color.number(`0x${txt[5]}${txt[6]}`);
          if (size > 7)
            a = Color.number(`0x${txt[7]}${txt[8]}`) / 255;
        }
        alpha = a;
        output = { r, g, b };
      } else if (txt.startsWith("rgb") || txt.startsWith("hsl")) {
        const [prefix = "", value = ""] = txt.split(/[()]/);
        const [v1 = "", v2 = "", v3 = "", v4] = value.trim().split(/[,\s/]+/) ?? [];
        if (prefix.startsWith("hsl")) {
          let [s, h = "", angle = "", l] = v1.match(/^([0-9.]+)([a-z]*)/) ?? [];
          if (!/deg|turn|grad|rad/.test(angle))
            angle = "deg";
          h = Color.number(h);
          s = Color.number(v2);
          l = Color.number(v3);
          output = { h, s, l, angle };
        } else {
          r = Color.number(v1, 255);
          g = Color.number(v2, 255);
          b = Color.number(v3, 255);
          output = { r, g, b };
        }
        if (v4) {
          a = Color.number(v4);
        }
        alpha = a;
      }
      if (alpha !== void 0) {
        alpha = Color.number(alpha);
        if (alpha < 0) {
          alpha = 0;
        } else if (alpha > 1) {
          alpha = 1;
        }
        output.a = alpha;
      }
    }
    return output;
  }
  static convertRGBtoHSL(r, g, b) {
    if (typeof r !== "number")
      throw new Error("missing red for conversion to HSL");
    const [red, green, blue] = [r / 255, g / 255, b / 255];
    const [min, max] = [Math.min(red, green, blue), Math.max(red, green, blue)];
    const diff = max - min;
    let h;
    let s;
    let l;
    h = s = l = 0;
    if (diff === 0) {
      h = 0;
    } else if (max === red) {
      h = (green - blue) / diff % 6;
    } else if (max === green) {
      h = (blue - red) / diff + 2;
    } else {
      h = (red - green) / diff + 4;
    }
    const angle = "deg";
    h = Math.round(h * 60) % 360;
    if (h < 0)
      h += 360;
    l = (max + min) / 2;
    s = diff / (1 - Math.abs(2 * l - 1));
    return { h, s, l, angle };
  }
  static convertHSLtoRGB(hue, saturation, luminescence, angleUnits = "deg") {
    if (typeof hue !== "number")
      throw new Error("missing hue for conversion to RGB");
    let degrees = hue;
    if (!angleUnits.includes("deg")) {
      if (angleUnits.includes("rad")) {
        degrees = hue * 180 / Math.PI;
      } else if (angleUnits.includes("grad")) {
        degrees = hue * 360 / 400;
      } else if (angleUnits.includes("turn")) {
        degrees = hue * 360;
      }
    }
    let r;
    let g;
    let b;
    r = g = b = 0;
    const chroma = (1 - Math.abs(2 * luminescence - 1)) * saturation;
    const x = chroma * (1 - Math.abs(degrees / 60 % 2 - 1));
    const m = luminescence - chroma / 2;
    const section = Math.floor(degrees % 360 / 60);
    switch (section) {
      case 0:
        r = chroma;
        g = x;
        b = 0;
        break;
      case 1:
        r = x;
        g = chroma;
        b = 0;
        break;
      case 2:
        r = 0;
        g = chroma;
        b = x;
        break;
      case 3:
        r = 0;
        g = x;
        b = chroma;
        break;
      case 4:
        r = x;
        g = 0;
        b = chroma;
        break;
      default:
        r = chroma;
        g = 0;
        b = x;
    }
    r = Math.round((r + m) * 255);
    g = Math.round((g + m) * 255);
    b = Math.round((b + m) * 255);
    return { r, g, b };
  }
  toHSL() {
    const { r, g, b } = this;
    const convert = Color.convertRGBtoHSL(r, g, b);
    Object.assign(this, convert);
    return this;
  }
  toRGB() {
    const { h, s, l, angle = "deg" } = this;
    const convert = Color.convertHSLtoRGB(h, s, l, angle);
    Object.assign(this, convert);
    return this;
  }
  constructor(colorLike) {
    const input = Color.parse(colorLike);
    Object.assign(this, { a: 1 }, input);
  }
  // explicit rgba(r,g,b, alpha)
  get rgba() {
    return this.toString("rgba");
  }
  // rgb(r,g,b) include alpha when it exists
  get rgb() {
    return this.toString("rgb");
  }
  // hsl(h, s, l, a) hsl includes optional alpha when exists
  get hsl() {
    return this.toString("hsl");
  }
  // #rgb and alpha when it exists #rrggbbaa
  get hex() {
    return this.toString("hex");
  }
  toString(as = "hex") {
    let { r, g, b, h, s, l, a, angle } = this;
    if (typeof r !== "number" && typeof h !== "number")
      return "Invalid Color";
    let prefix = as || (typeof h === "number" ? "hsl" : "rgb");
    let alpha = "";
    if (prefix.endsWith("a") || a >= 0 && a < 1) {
      a = +a || 0;
      if (a < 0 || a > 1) {
        a = 1;
      }
      alpha = a.toPrecision(2);
      if (alpha.length > 2 && alpha.endsWith("0")) {
        alpha = a.toPrecision(1);
      }
    }
    if (prefix.startsWith("hsl")) {
      if (typeof h !== "number") {
        this.toHSL();
        h = this.h;
        s = this.s;
        l = this.l;
      }
      const hsl = [h + (angle || ""), `${(s * 100).toFixed()}%`, `${(l * 100).toFixed()}%`];
      if (alpha)
        hsl.push(alpha);
      return `hsl(${hsl.join(", ")})`;
    }
    if (typeof r !== "number") {
      this.toRGB();
      r = this.r;
      g = this.g;
      b = this.b;
    }
    if (prefix.startsWith("hex")) {
      const rgb = [r, g, b];
      if (alpha) {
        rgb.push(Math.round(a * 255));
      }
      const short = ["", ""];
      const rrggbb = rgb.map((n) => {
        if (n === void 0)
          return "";
        let hx = n.toString(16);
        if (hx.length < 2)
          hx = `0${hx}`;
        const [h0, h1] = hx.split("");
        short[0] += h0;
        short[1] += h1;
        return hx;
      });
      const hex = short[0];
      return `#${hex === short[1] ? hex : rrggbb.join("")}`;
    }
    if (prefix.startsWith("rgb")) {
      const rgb = [r, g, b];
      prefix = "rgb";
      if (alpha) {
        prefix = "rgba";
        rgb.push(alpha);
      }
      return `${prefix}(${rgb.join(", ")})`;
    }
    return "Invalid Color";
  }
}
export {
  Color as default
};
//# sourceMappingURL=color.js.map
