export declare function merge(to: any, ...from: any[]): any;
/**
 * Omni standard for displaying localized dates
 *
 * @param      {Date}   date                      a Date object
 * @param      {Object} [formatOverides]          any overrides to base display format
 * @returns    {String}                           the date string to display
 *
 * @example
 * const displayDate = dateToString(new Date)
 * //=> (for en-US locale) Jul 8, 2019
 * @example
 * const displayDate = dateToString(new Date, { year: undefined })
 * //=> (for en-US locale) Jul 8
 */
export declare function dateToString(date: Date, formatOverrides: object): string;
/**
 * Omni standard for displaying localized time
 *
 * @param      {Date} date                        a Date object
 * @param      {Object} [formatOverides]          any overrides to base display format
 * @returns    {String}                           the time string to display
 *
 * @example
 * const displayTime = dateToTimeString(new Date)
 * //=> (for en-US locale) 9:59 AM
 */
export declare function dateToTimeString(date: Date, formatOverrides?: object): string;
/**
 * Omni standard for displaying relative time values
 *
 * @param     {Date} d1                           a Date object
 * @param     {Date} d2                           a second Date object (defaults to now)
 * @param     {String} [locale]                   a locale whose formatting conventions should be used
 * @param     {Object} [optionOverrides]          any overrides to base compare options
 * @returns   {String}                            the relative time string to display
 *
 * @example
 * const displayTime = dateToRelativeTimeString(new Date)
 * //=> (for en-US locale) 3 days ago
 */
export declare function dateToRelativeTimeString(d1: Date, d2: Date, locale: string, optionOverrides: any): any;
/** sort strings */
export declare function sortString(a: any, b: any, locale: any, options?: {
    sensitivity: string;
}): 1 | 0 | -1;
/** sort numbers */
export declare function sortNumber(a: any, b: any): 1 | 0 | -1;
/**
 * Omni standard for a sorting human-readable strings
 *
 * @param     {Array} arry               an Array of Strings to sort
 * @param     {String} [locale]          a locale whose formatting conventions should be used
 * @param     {Object} [options]         options merged with defaults
 * @param     {Function} [fn]            optional sort operator
 * @returns   {Array}                    a sorted copy of the input Array
 *
 * @example
 * const sortedArry = sort(['2', 'Foo', 'é', 'E', 'e', 'bar', '1'])
 * //=> [ '1', '2', 'bar', 'é', 'E', 'e', 'Foo' ]
 */
export declare function sort<T>(arry: T[], locale?: string, options?: object, fn?: (a: any, b: any) => number): T[];
/**
 * Omni standard for sorting object arrays by a property with human-readable string values
 *
 * @param     {Array} arry               an Array of Objects to sort
 * @param     {String} key               a name of an Object property to access
 * @param     {String} [locale]          a locale whose formatting conventions should be used
 * @param     {Object} [options]         options merged with defaults
 * @param     {Function} [fn]            optional sort operator
 * @returns   {Array}                    a sorted copy of the input Array
 *
 * @example
 * const sortedArry = sortObjects([{name: 'Olga', age: 36}, {name: 'Nathan', age: 40}], 'name')
 * //=> [ {name: 'Nathan', age: 40}, {name: 'Olga', age: 36} ]
 */
export declare function sortObjects<T>(arry: T[], key: string, locale?: string, options?: object, fn?: (a: any, b: any) => number): T[];
/** fetch a resource
 * see MDN and the various linked content about this API:
 * https://developer.mozilla.org/docs/Web/API/Fetch_API
 * see also AbortController, caching, HTTP headers, etc that relate to various requirements
 */
export declare function fetching(resource: any, options: any): Promise<any>;
/** fetch JSON see fetching */
export declare function fetchJSON(url: any, options: any): Promise<any>;
/** fetch text see fetching */
export declare function fetchText(url: any, options: any): Promise<any>;
/** fetch CSS see fetching */
export declare function fetchCSS(url: any, options: any): Promise<any>;
/**
 * @internal
 * Regexp patern for matching the URL of CSS import at-rules in a given string
 * NOTE:
 * 	 Currently supports the `<at>import "my.css"` variant only
 * 	 Pattern is also used in rollup.config.js, tread lightly
 * @type {RegExp}
 */
export declare const cssImportAtRulePtn: RegExp;
/**
 * @internal
 * A workaround for deprecated CSS import at-rules in CSSStyleSheet.replace()
 * NOTE: Only replaces first top-level import found
 * (https://chromestatus.com/feature/4735925877735424)
 *
 * @param     {CSSStyleSheet} sheet      instance of sheet
 * @param     {String} importOrCSS       CSS import statement or CSS string
 * @returns   {Promise}                  promise that resolves to Response object
 *
 * @example (replace <at> with @)
 * const omniStandardStyleSheet = new CSSStyleSheet();
 * styleSheetReplaceImport(omniStandardStyleSheet, '<at>import "/standard.css"')
 * 	 .catch(handleStyleSheetImportError);
 */
export declare function styleSheetReplaceImport(sheet: any, importOrCSS: any): any;
export declare function capitalizeFirstWord(phrase: any): any;
/** @internal */
export declare function areUrlsEqualish(url1: any, url2: any): boolean;
export declare function memoize(fn: any): any;
/**
 * Debounce given function so it does not run until wait milliseconds after the last call.
 * If immediate flag is true, then it will run on the first call and not run again until wait milliseconds
 * after the last call.
 *
 * Based off following sources:
 * https://davidwalsh.name/javascript-debounce-function
 * https://levelup.gitconnected.com/debounce-in-javascript-improve-your-applications-performance-5b01855e086
 *
 * @param func {function} function to debounce
 * @param wait {number} time to wait in milliseconds
 * @param immediate {boolean} True if function should be called on the leading edge instead of trailing edge
 * @return {function}
 */
export declare function debounce(func: any, wait: any, immediate?: boolean): (...args: any[]) => void;
/**
 * give a file name with an extension and truncate to a smaller version with ellipses in place
 * if filename is < , it returns unmodified
 * if no extension is found in the string, it return unmodified
 * @param {string} filename
 * @param {number=} truncateAt
 * @return {string}
 */
export declare function truncateFilename(filename: string, truncateAt?: number | undefined): string;
/**
 * use browser crypto to get a hash of a string
 */
export declare function hashString(string: string, algorithm?: string): Promise<string>;
/**
 *  - returns first matching element from depth-first dom traversal
 *  - comparable to `document.querySelector`, but this adds the ability to pierce shadow roots indefinitely
 *  - useful when you would want to get a reference to an element that is outside of your current root
 *  - not as useful to query for an internal element that you don't control, .e.g., omni-table internal elements
 *  @example
 *  ```js
 *     // if dom currently has `<omni-card id="1234"></omni-card>` within any root, the element is returned
 *     const element = querySelectorDeep('omni-card', '1234');
 *     // then you can call an element method
 *     element.doSomething();
 *     // to narrow the scope of your query, provide a shadow root
 *     // the element will be returned if the `<omni-card id="1234"></omni-card>` is within or a descendant of the given shadowRoot
 *     // ... in your element class
 *     const element = querySelectorDeep('omni-card', '1234', this.shadowRoot);
 *  ```
 *  @param {string} tagName the tag name of the element
 *  @param {string=} id (optional) the dom id for the element
 *  @param {Document | ShadowRoot=} rootNode (optional) pass a shadow root to only include that shadow root and its descendants
 *  @returns {HTMLElement | undefined} element | undefined
 */
export declare function querySelectorDeep(tagName: string, id?: string, rootNode?: Document | ShadowRoot): HTMLElement | undefined;
/** @internal */
export interface ResizeOptions {
    edits: {
        resize: {
            width: number;
            height: number;
            fit: 'cover' | 'contain' | 'fill' | 'inside' | 'outside';
        };
    };
    toFormat: 'png' | 'jpeg' | 'tiff' | 'webp' | 'raw';
}
/**
 * @param {string} url -> Image URL with image key(encode in url)
 * @param {ResizeOptions} options  -> the resize options
 * @returns {string} -> New image URL with all modification as specified in the options object.
 */
export declare function resizeImage(url: string, options: ResizeOptions): string;
/**
 * - get element size including margin (default includes margin);
 * - numbers are integers
 * - will include padding if element is border-box (default for omni-elements)
 *  @param {HTMLElement} element the tag name of the element
 *  @param {boolean=} includeMargin (optional) the dom id for the element
 *  @returns {{width: number, height: number}} width and height
 */
export declare function getElementSize(element: HTMLElement, includeMargin?: boolean): {
    width: number;
    height: number;
};
/** @internal */
export type Environment = 'local' | 'dev' | 'qa' | 'stg' | 'prod';
/**
 * @internal
 * Treat local environment as dev, all others are themselves
 */
export declare const ssoEnv: (env: Environment) => Environment;
/**
 * @internal
 * Determine the hostname given a base hostname and env.
 * "local" + "omni.annalect.com" => "devomni.annalect.com"
 */
export declare const ssoHost: (env: Environment, host: string) => string;
/** @internal */
export declare const fetchOmni: (env: Environment, path: string, options: any) => Promise<any>;
export declare const generateToken: (env: Environment, clientId: string, sid: string, typeKey: string) => Promise<string>;
interface JWTPayload {
    client_guid: string;
    omniTypeKeys?: string[];
    ANsid: string;
    roles?: string[];
}
export declare const parseJWT: (token: string) => JWTPayload;
export declare const userHasRole: (jwt: string, typeKey: string, requiredRoles?: any[]) => boolean;
export {};
//# sourceMappingURL=omni-util.d.ts.map