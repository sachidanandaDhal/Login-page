function mergekeyvalue(to, [key, value]) {
  const orig = to[key];
  if (orig && typeof orig === "object" && typeof value === "object") {
    merger(orig, value);
  } else {
    to[key] = value;
  }
  return to;
}
function merger(to, from) {
  if (Array.isArray(to) && Array.isArray(from)) {
    to.push(...from);
  } else if (from) {
    let source;
    try {
      source = structuredClone(from);
    } catch (e) {
      source = from;
    }
    Object.entries(source).reduce(mergekeyvalue, to);
  }
  return to;
}
function merge(to, ...from) {
  const copyTarget = structuredClone(to);
  return from.reduce(merger, copyTarget ?? {});
}
const baseDateFormat = { month: "short", day: "numeric", year: "numeric" };
const baseTimeFormat = { hour: "numeric", minute: "numeric" };
const baseRelTimeFormatOptions = { numeric: "auto" };
const timeUnits = {
  year: 24 * 60 * 60 * 1e3 * 365,
  month: 24 * 60 * 60 * 1e3 * 365 / 12,
  day: 24 * 60 * 60 * 1e3,
  hour: 60 * 60 * 1e3,
  minute: 60 * 1e3,
  second: 1e3
};
function dateToString(date, formatOverrides) {
  return date.toLocaleDateString("default", merge(baseDateFormat, formatOverrides));
}
function dateToTimeString(date, formatOverrides = {}) {
  return date.toLocaleTimeString("default", merge(baseTimeFormat, formatOverrides));
}
function dateToRelativeTimeString(d1, d2 = /* @__PURE__ */ new Date(), locale = "en", optionOverrides) {
  let isRelativeTimeSupported = false;
  try {
    new Intl.RelativeTimeFormat("en", { numeric: "auto" });
    isRelativeTimeSupported = true;
  } catch (err) {
    console.log("Falling back to a regular date/time string due to Intl.RelativeTimeFormat not being supported.");
  }
  let result;
  if (isRelativeTimeSupported) {
    const rtf = new Intl.RelativeTimeFormat(locale, merge(baseRelTimeFormatOptions, optionOverrides));
    const elapsed = d1 - d2;
    Object.entries(timeUnits).some((unitEntry) => {
      if (Math.abs(elapsed) > unitEntry[1] || unitEntry[0] === "second") {
        result = capitalizeFirstWord(rtf.format(Math.round(elapsed / unitEntry[1]), unitEntry[0]));
        return true;
      }
      return false;
    });
  } else {
    result = dateToString(new Date(d1));
  }
  return result;
}
const baseCompareOptions = { sensitivity: "base" };
function sortString(a, b, locale, options = baseCompareOptions) {
  const d = a.localeCompare(b, locale, options);
  return d < 0 ? -1 : d > 0 ? 1 : 0;
}
function sortNumber(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
function sort(arry, locale = "en", options = {}, fn = (a, b) => sortString(a, b, locale, options)) {
  const merged = { ...baseCompareOptions, ...options };
  Object.assign(options, merged);
  return [...arry].sort(fn);
}
function sortObjects(arry, key, locale = "en", options = {}, fn = (a, b) => sortString(a[key], b[key], locale, options)) {
  return sort(arry, locale, options, fn);
}
const responseForCode = {
  204: () => null
};
function responseOK(res) {
  if (res.ok) {
    if (res.status in responseForCode) {
      res.json = responseForCode[res.status];
    }
    return res;
  }
  return Promise.reject(res);
}
function fetching(resource, options) {
  return fetch(resource, options).then(responseOK);
}
const baseFetchOptions = {
  headers: {
    Accept: "application/json",
    "Content-Type": "application/json"
  },
  cache: "no-store"
};
function fetchJSON(url, options) {
  return fetching(url, merge(baseFetchOptions, options)).then((res) => res.json());
}
function fetchText(url, options) {
  return fetching(url, merge(baseFetchOptions, { headers: { Accept: "text/plain" } }, options)).then((res) => res.text());
}
function fetchCSS(url, options) {
  return fetching(url, merge(baseFetchOptions, { headers: { Accept: "text/css" } }, options)).then((res) => res.text());
}
const cssImportAtRulePtn = /\s*@import\s+(?:"|')([^"')]+)(?:"|')\s*/;
function styleSheetReplaceImport(sheet, importOrCSS) {
  const matches = cssImportAtRulePtn.exec(importOrCSS);
  if (!matches)
    return sheet.replace(importOrCSS);
  return fetchCSS(matches[1]).then((css) => sheet.replace(css));
}
function capitalizeFirstWord(phrase) {
  return phrase.replace(/^\w/, (c) => c.toUpperCase());
}
const trailingSlashesPathReplacePtn = /\/+$/;
function areUrlsEqualish(url1, url2) {
  const u1 = new URL(url1);
  const u2 = new URL(url2);
  const pathsimilar = u1.pathname.replace(trailingSlashesPathReplacePtn, "") === u2.pathname.replace(trailingSlashesPathReplacePtn, "");
  return u1.origin === u2.origin && pathsimilar && u1.search === u2.search;
}
function memoize(fn) {
  return new Proxy(fn, {
    //@ts-ignore
    cache: /* @__PURE__ */ new Map(),
    apply(target, thisArg, argsList) {
      const cacheKey = JSON.stringify(argsList);
      if (!this.cache.has(cacheKey))
        this.cache.set(cacheKey, target.apply(thisArg, argsList));
      return this.cache.get(cacheKey);
    }
  });
}
function debounce(func, wait, immediate = false) {
  let timeout;
  return (...args) => {
    const callNow = immediate && !timeout;
    const later = () => {
      timeout = null;
      if (!immediate)
        func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow)
      func(...args);
  };
}
function truncateFilename(filename, truncateAt = 10) {
  if (!filename.includes("."))
    return filename;
  const split = filename.split(".");
  if (split[0].length - 3 <= truncateAt)
    return filename;
  const first = filename.slice(0, truncateAt);
  const end = split[0].slice(split[0].length - 3, split[0].length);
  split.shift();
  const result = `${first}...${end}.${split.join(".")}`;
  if (result.length > filename.length)
    return filename;
  return result;
}
async function hashString(string, algorithm = "SHA-256") {
  const bufferIn = new TextEncoder().encode(string);
  const bufferOut = await crypto.subtle.digest(algorithm, bufferIn);
  return [...new Uint8Array(bufferOut)].map((bytes) => bytes.toString(16).padStart(2, "0")).join("");
}
function querySelectorDeep(tagName, id = null, rootNode = document) {
  function traverseNodes(nodeList) {
    for (const node of nodeList) {
      if (node.localName === tagName && (id ? id === node.id : true)) {
        return node;
      }
      if (node.shadowRoot) {
        const found = traverseNodes(node.shadowRoot.querySelectorAll("*"));
        if (found) {
          return found;
        }
      }
    }
  }
  return traverseNodes(rootNode.querySelectorAll("*"));
}
function resizeImage(url, options) {
  const arr = url.split("/");
  const encodedStr = arr[arr.length - 1].split("#")[0];
  const decodedObj = JSON.parse(atob(encodedStr));
  const newOption = {
    key: decodedObj.key,
    edits: options.edits
  };
  const encodeObj = btoa(JSON.stringify(newOption));
  arr.splice(arr.length - 1, 1);
  return arr.join("/") + "/" + encodeObj;
}
function getElementSize(element, includeMargin = true) {
  let { width, height } = element.getBoundingClientRect();
  if (includeMargin) {
    const computedStyle = getComputedStyle(element);
    width += parseInt(computedStyle.marginLeft) + parseInt(computedStyle.marginRight);
    height += parseInt(computedStyle.marginTop) + parseInt(computedStyle.marginBottom);
  }
  return {
    width: Math.trunc(width),
    height: Math.trunc(height)
  };
}
const ssoEnv = (env) => env === "local" ? "dev" : env;
const ssoHost = (env, host) => {
  let prefix = ssoEnv(env);
  if (prefix === "prod")
    prefix = "";
  return `${prefix}${host}`;
};
const fetchOmni = async (env, path, options) => {
  const url = `https://${ssoHost(env, "omni.annalect.com")}${path}`;
  const response = await fetch(url, options);
  return response.json();
};
const generateToken = async (env, clientId, sid, typeKey) => (await fetchOmni(env, `/api/jwt/${clientId}/?ANsid=${sid}`, {
  method: "POST",
  body: JSON.stringify({
    omniTypeKeys: [typeKey],
    withRoles: true
  })
})).jwt;
const parseJWT = (token) => {
  const base64Url = token.split(".")[1];
  const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
  const jsonPayload = decodeURIComponent(
    window.atob(base64).split("").map((c) => `%${`00${c.charCodeAt(0).toString(16)}`.slice(-2)}`).join("")
  );
  return JSON.parse(jsonPayload);
};
const userHasRole = (jwt, typeKey, requiredRoles = []) => {
  try {
    const { omniTypeKeys, roles } = parseJWT(jwt);
    const appIndex = omniTypeKeys?.indexOf(typeKey);
    const userRoles = roles?.[appIndex]?.split(",") ?? [];
    const matches = userRoles.filter((x) => requiredRoles.includes(x));
    return matches.length > 0;
  } catch {
    return false;
  }
};
export {
  areUrlsEqualish,
  capitalizeFirstWord,
  cssImportAtRulePtn,
  dateToRelativeTimeString,
  dateToString,
  dateToTimeString,
  debounce,
  fetchCSS,
  fetchJSON,
  fetchOmni,
  fetchText,
  fetching,
  generateToken,
  getElementSize,
  hashString,
  memoize,
  merge,
  parseJWT,
  querySelectorDeep,
  resizeImage,
  sort,
  sortNumber,
  sortObjects,
  sortString,
  ssoEnv,
  ssoHost,
  styleSheetReplaceImport,
  truncateFilename,
  userHasRole
};
//# sourceMappingURL=omni-util.js.map
