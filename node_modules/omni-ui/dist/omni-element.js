import { LitElement, css, html } from "lit";
import * as styles from "./styles.js";
const defaultDispatchNewEventOptions = {
  bubbles: true,
  composed: true,
  cancelable: true
};
class OmniElement extends LitElement {
  /**
   * Sensible default styles for a new custom element
   */
  static get styles() {
    const styles2 = [
      css`
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none;
        }

        *,
        *::before,
        *::after,
        .omni *,
        .omni *::before,
        .omni *::after {
          box-sizing: border-box;
        }
      `
    ];
    if (super.styles)
      styles2.unshift(super.styles);
    return styles2;
  }
  /**
   * Static method for defining a custom element with the registry. Explicit registration
   * makes the module side-effect free enabling apps to tree-shake unused components.
   *
   * @param  {String=}   name        Tag name for the new custom element
   * @param  {Function=} constructor Constructor for the new custom element
   * @param  {Object=}   [options]   Control how the element is defined
   */
  static register(name = "", constructor = null, options = {}) {
    if (!(name && constructor)) {
      return;
    }
    const existing = customElements.get(name);
    if (!existing) {
      customElements.define(name, constructor, options);
    }
  }
  /** (iterator) utility for finding/filtering CSS selector (as 'this') matches node
   * @internal
   * @returns { boolean } indicates matches selector
   */
  static _nodeMatches(node) {
    return node.matches ? node.matches(this) : false;
  }
  /** event path utility for finding or filtering nodes
   @param { object } event - an Event object
   @param { string } cssSelector - 
    a valid CSS selector to match against, if falsy the path array of nodes is returned
   @param { boolean } collectFilter - 
    true (truthy) returns filtered array of nodes matching cssSelector
    false (default) returns array with the first node matching cssSelector
   @returns { Array } - array of 0 or more nodes
   */
  static pathfinder(event, cssSelector = "", collectFilter) {
    const path = event.composedPath();
    if (cssSelector) {
      if (collectFilter) {
        return path.filter(this._nodeMatches, cssSelector);
      }
      const node = path.find(this._nodeMatches, cssSelector);
      return node ? [node] : [];
    }
    return path;
  }
  /** @internal */
  pathfinder(event, cssSelector = "", collectFilter) {
    return OmniElement.pathfinder(event, cssSelector, collectFilter);
  }
  /**
   * @internal
   * @deprecated
   * deprecate with warning and remove in a future version */
  get __dispatchNewEvent() {
    console.warn(
      "replace `__dispatchNewEvent` with `dispatchNewEvent`, __dispatchNewEvent will be deprecated in a future release"
    );
    return this.dispatchNewEvent;
  }
  /**
   * Convenience method for creating and dispatching an event in a single call
   *
   * @param  {String}  type      Event's type
   * @param  {Object}  [options] Event creation option overrides
   *                               (see defaultDispatchNewEventOptions)
   * @param  {Element} [target]  Event target (defaults to this)
   * @return {CustomEvent & {cancelled: boolean}}             Event object decorated with cancelled boolean flag
   * @note previously returned Array[event, wasNotCancelled result of dispatchEvent]
   */
  dispatchNewEvent(type, optionOverrides = {}, target = this) {
    const options = { ...defaultDispatchNewEventOptions, ...optionOverrides };
    const event = new CustomEvent(type, options);
    if (super.dispatchNewEvent)
      super.dispatchNewEvent(type, options, target);
    const wasNotCancelled = target.dispatchEvent(event);
    event.cancelled = !wasNotCancelled;
    return event;
  }
  render() {
    return html`<slot></slot>`;
  }
}
OmniElement.register("omni-element", OmniElement);
export {
  OmniElement,
  styles
};
//# sourceMappingURL=omni-element.js.map
